/*
	- 기억 공간의 유형은 여러 파일에 걸쳐 정보를 공유하는 방법에 영향을 준다.
	- C++의다양한 기억 공간은 기억 존속시간, 사용 범위, 링크에 의해 그 속성이 구별 된다.

	< 기억 존속 시간 >
	- C++는 네 가지 유형으로 데이터를 저장한다. 이 네가지 유형은 메모리에 데이터를 존속시키는 시간에서 차이가 난다.
		1. 자동 기억 존속 시간
			: 함수 매개변수, 함수 정의 안에 선언된 변수
		2. 정적 기억 존속 시간
			: 함수 정의의 바깥에서 정의된 변수, 키워드 static을 사용하여 정의된 변수
		3. 쓰레드 존속 시간
		4. 동적 기억 존속 시간

	< 사용 범위, 링크 >
	- 사용 범위
		: 어떤 이름이 하나의 파일(번역 단위) 안에서 얼마나 널리 알려지는가를 나타냄.
			1. 지역 사용 범위
			2. 전역 사용 범위
			3. 함수 원형 사용 범위
			4. 클래스 사용 범위
			5. 이름 공간 사용 범위
		: 자동 변수는 지역 사용 범위를 가진다.
		: 정적 변수는 그것이 어떻게 정의되는가에 따라 지역 사용 범위와 전역 사용 범위 중 어느 하나를 가진다.
	- 링크
		: 서로 다른 번역 단위들이 이름을 공유하는 것.
			1. 외부 링크
				: 외부 링크를 가진 이름은 여러 파일들이 공유할 수 있다.
			2. 내부 링크
				: 내부 링크를 가진 이름은 한 파일 안에 있는 함수들만 공유할 수 있다.
			3. 링크 없음
		: 자동 변수는 공유되지 않기 때문에 자동 변수의 이름은 링크를 갖지 않는다.
*/

/*
	< 자동 변수 >
	- 자동 기억 존속 시간
	- 지역 사용 범위, 링크 없음
	- 초기화
		: 그 선언에 도달된 시점에서 값을 알 수 있다면, 어떠한 표현식을 사용하더라도 초기화 할 수 있다.
	- 자동 변수는 스택에 저장되는데 프로그램은 두 개의 포인터를 이용하여 이 스택을 관리한다.

	< 정적 변수 >
	- 정적 기억 존속 시간
		: 프로그램이 싱행을 시작한 시점부터 실행을 종료하는 시점까지 계속해서 존재한다.
	- C++는 세 가지 유형의 링크를 가지는 정적 변수를 제공한다.
		1. 외부 링크
			: 어떠한 블록에도 속하지 않는 완전한 바깥에 선언한다.
		2. 내부 링크
			: 어떠한 블록에도 속하지 않는 바깥에서 그것을 선언하되, static 이라는 기억 공간 제한자를 선안 앞에 붙인다.
		3. 링크 없음
			: static이라는 제한자를 사용하여 블록 안에서 그것을 선언한다.
	- 초기화
		: 정적 변수를 명시적으로 초기화하지 않으면, 컴파일러는 그것을 모두 0으로 초기화 한다.
		  정적 배열과 구조체는 그것의 원소나 멤버가 기본적으로 0으로 설정된다.
		  (초기화되지 않은 정적 변수들은 모든 비트가 0으로 세팅 되는데 이것을 제로 초기화라고 한다.)
*/

/*
	< 제한자 >
	- 기억 공간 제한자
		1. auto
			: C++11 이전 -> 어떤 변수가 자동 변수라는 선언에 사용
			: C++11 이후 -> 자동 형변환에 사용
		2. register
			: CPU의 레지스터 기억 공간을 지정하는 선언에 사용
			: C++11 에서는 단순히 자동 변수라는 것을 의미히는 명시적인 방법이다.
		3. static
			: 파일 범위 선언에 사용될 때 -> 내부 링크를 나타냄
			: 지역 선언에 사용될 때	   -> 지역 변수를 위한 정적 기억 존속 시간을 가리킴
		4. extern
			: 참조 선언을 나타냄 (그 선언은 다른 곳에 이미 정의되어 있는 변수를 참조한다.)
		5. thread_local
			: 쓰레드 존속시간
			: 정적 변수의 존속 시간은 프로그램의 존속 시간과 같지만, thread_local 변수는 존속 시간이 쓰레드의 존속 시간과 같다.
		6. mutable
			: 특정 구조체 또는 클래스가 const로 선언되어 있다 하더라도 그 구조체의 특정 멤버를 변경할 수 있음을 나타내는데 사용할 수 있다.
	- cv 제한자
		1. const
			: 메모리가 일단 초기화된 후에는 프로그램이 그 메모리를 변경할 수 없다는 뜻이다.
		2. volatile
			: 프로그램 코드가 변경하지 않더라도 특정 메모리 위치에 있는 값이 변경될 수 있다는 것을 나타낸다.
			: 컴파일러 최적화와 관련
				컴파일러가 어떤 변수의 값이 두 번 사용되고 있는 것을 발견했다고 가정할 때,
				컴파일러는 프로그램이 그 값을 두 번 조사하게 하지않고, 레지스터에서 직접 그 값을 캐시할 수 있다.
				이러한 최적화는 그 변수가 두 번 사용되는 동안에 값이 변하지 않는다고 가정 한다.
				어떤 변수를 volatile로 선언하지 않으면 컴파일러가 이러한 최적화를 자유로이 수행할 수 있지만,
				volatile로 선언하면 컴파일러가 이러한 최적화를 수행하지 못하게 된다.
*/

/*
	< 이름 공간 >
	1. 구식 C++ 이름 공간
	- 선언 영역
		: 선언을 할 수 있는 영역
		  ex) 전역 변수는 모든 함수의 바깥에서 선언할 수 있다.
		      그 변수의 선언 영역은 그것이 선언된 파일이다.
			  어떤 변수를 함수 안에 선언한다면, 그 변수의 선언 영역은 그것이 선언된 블록이다.
	- 잠재 사용 범위
		: 어떤 변수의 잠재 사용 범위는 그 변수를 선언한 지점부터 선언 영역의 끝까지이다.
		  변수는 처음으로 그것을 정의한 지점의 위에서는 사용할 수 없기 때문에, 잠재 사용범위는 선언 영역보다 좁다.
		  잠재 사용범위에서 변수가 보이지 않을 수도 있다.

	2. 새로운 이름 공간 기능
	- 새로운 종류의 선언 영역을 정의함으로써 이름이 명명된 이름 공간을 만들 수 있는 기능이 C++에 새로 추가 되었다.
	  그것의 주된 목적은 이름을 선언하는 영역을 따로 제공하는 것이다.
	  하나의 이름 공간에 속한 이름은, 동일한 이름으로 다른 이름 공간에 선언된 이름과 충돌하지 않는다.
	  
	- 그리고 프로그램을 구성하는 여러 부분들이 하나의 이름 공간에 선언된 이름을 사용할 수 있도록 허용하는 방법이 있다.
			namespace Jack {
				double pail;
				void fetch();
				int pal;
				struct Well {...};
			}
			namespace Jill {
				double bucket (double n) { ... }
				double fetch;
				int pal;
				struct Hill {...};
			}

	- 이름 공간은 전역 위치에 또는 다른 이름 공간 안에도 놓일 수 있다. 그러나 블록 안에는 놓일 수 없다.
	  그러므로 하나의 이름 공간에 선언된 이름은, 기본적으로 외부 링크를 가진다.

	- 사용자가 정의하는 이름 공간 외에, 전역 이름 공간이라는 또 하나의 이름 공간이 있다.
	  이것은 파일 수준의 선언 영역에 해당한다. 그러므로 우리가 전역 변수라고 불러 왔던 것들은 전역 이름 공간의 일부라고 할 수 있다.

	- 이름 공간은 항상 열려 있기 때문에, 기존의 이름 공간에 새로운 이름을 추가할 수 있다.
			namespace Jill {
				char* goose(const char*);	// 새로운 함수 원형 추가
			}
			namespace Jack {
				void fetch()	// 기존에 존재하는 함수 원형에 대한 함수 정의 코드 제공
				{
					...
				}
			}

	- 어떤 주어진 이름 공간에 속해 있는 이름에 접근할 수 있는 방법
		
		1. 사용 범위 결정 연산자(::)를 사용하여, 어떤 이름을 주어진 이름 공간으로 제한한다.
			Jack::pail = 12.34;		// 제한된 이름
			Jill::Hill mole;		// 제한된 이름
			Jack::fetch();			// 제한된 이름
		
		2. 사용할 때마다 매번 이름을 제한한다는 것은 성가시므로 using 선언과 using 지시자를 사용한다.
			2-1. using 선언
				: 하나의 특별한 식별자를 사용할 수 있게 만든다.
				  제한된 이름 앞에 키워드 using을 붙인다.
					using Jill:fetch;
				: using 선언은 그것이 나타나는 선언 영역에 하나의 특별한 이름을 추가한다.
				  using 선언을 블록 안에 넣으면 지역 이름 공간에 추가된다.
				  using 선언을 외부 위치에 넣으면 그 이름이 전역 이름 공간에 추가된다.
				  이 선언을 한 이후에는 Jill:fetch 대신에 fetch라는 이름을 사용할 수 있다.

			2-2: using 지시자
				: 그 이름 공간 전체에 접근할 수 있게 만든다.
				  하나의 이름 공간 앞에 using namespace 라는 키워드를 붙인다.
				  이렇게 하면 사용 범위 결정 연산자를 사용하지 않고도 그 이름 공간에 속한 모든 이름을 사용할 수 있게 된다.

					using namespace Jack	// Jack에 속한 모든 이름들을 사용할 수 있게 만든다.
					
					#include <iostream>		// 이름들을 std라는 이름 공간에 넣는다.
					using namespace std;	// 이름들을 전역적으로 사용할 수 있게 만든다.

		3. ex
			
			namespace Jill {
				double bucket (double n) {...};
				double fetch;
				struct Hill {...};
			}

			char fetch;								// 전역 이름 공간

			int main()
			{
				using namespace Jill;				// 그 이름 공간의 모든 이름을 불러온다.
				Hill Thrill;						// Jill:Hill 구조체를 생성
				double water = bucket(2);			// Jill:bucket(); 을 사용
				double fetch;						// 지역 이름 공간에 변수 선언 Jill:fetch를 가린다.
				cin >> fetch;						// 지역 이름 공간 사용
				cin >> ::fetch;						// 전역 이름 공간 사용
				cin >> Jill::fetch;					// Jill::fetch 사용
				...
			}
			int foom()
			{
				Hill top;							// X
				Jill::Hill crest;					// O
			}

		4. 가이드라인
			1. 외부 전역 변수를 사용하지 말고, 이름이 명명된 이름 공간에 있는 변수를 사용한다.
			2. 정적 전역 변수를 사용하지 말고, 이름이 명명되지 않은 이름 공간에 있는 변수를 사용한다.
			3. 함수 또는 클래스 라이브러리를 개발하고 있다면, 그들을 하나의 이름 공간에 넣는다.
			   실제로 현재 C++는 표준 라이브러리 함수들을 std라는 이름 공간에 넣을 것을 요구하고 있다.
			4. using 지시자는, 옛날 코드를 이름 공간 용도로 변환하는 임시 수단으로만 사용한다.
				ex) math.c 헤더파일은 이름 공간을 사용하지 않는다. 그러나 cmath 헤더파일은 std 이름공간에 다양한 수학 라이브러리 함수들을 넣는다.
			5. using 지시자를 헤더 파일에 사용하지 않는다.
			6. 사용 범위 결정 연산자 또는 using 선언을 사용하여 이름을 선택적으로 들여온다.
			7. using 선언에 대해 전역 범위 대신 선택적으로 지역 범위를 사용한다.
		


			
*/