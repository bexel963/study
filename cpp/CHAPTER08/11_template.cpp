#include <iostream>

template <class Any>
void Swap(Any& a, Any& b);


int main()
{
	using namespace std;
	int i = 10;
	int j = 20;
	cout << "i, j = " << i << ", " << j << ".\n";
	cout << "컴퍼일러가 생성한 int형 교환기를 사용하면\n";
	Swap(i, j);
	cout << "이제 i, j = " << i << ", " << j << ".\n\n";
	
	double x = 24.5;
	double y = 81.5;
	cout << "x, y = " << x << ", " << y << ".\n";
	cout << "컴퍼일러가 생성한 double형 교환기를 사용하면\n";
	Swap(x, y);
	cout << "이제 x, y = " << x << ", " << y << ".\n";

	return 0;
}

template <class Any>	// class 대신 typename을 새용해도 된다.
void Swap(Any& a, Any& b)
{
	Any temp;
	temp = a;
	a = b;
	b = temp;
}
/*
	- 이 템플릿은 함수를 만드는 것이 아니다. 함수를 정의하는 방법을 컴파일러에게 일러 주는 것이다.
	- 다양한 데이터형에 대해 동일한 알고리즘을 적용해야 하는 함수가 필요하다면, 템플릿을 사용해야 한다.
	- 이 함수를 사용하면 컴파일러는 매개변수의 데이터형을 검사하여, 그에 대응하는 함수를 생성한다.
		=> 최종적으로 산출되는 코드에는 어떠한 템플릿도 포함되지 않는다. 그 프로그램을 위해 생성된 실제 함수들만 포함된다.
		   그러므로 함수 템플릿이 실행 프로그램을 짧게 만들어 주지는 않는다. 여기서는 두 함수를 수동으로 정의할 때와 마찬가지로 별개의 두 함수 정의가 생성된다.
*/


/*
	- 함수 템플릿은 함수의 일반화 서술이다. 즉, 함수 템플릿은 int형이나 double형과 같은 구체적인 데이터형을 포괄할 수 있는 일반형으로 함수를 정의한다.
	  어떤 데이터형을 템플릿에 매개변수로 전달하면, 컴파일러가 그 데이터형에 맞는 함수를 생성한다.
	  템플릿은 구체적인 데이터형 대신에 일반형으로 프로그래밍을 하게 되므로, 이것을 일반화 프로그래밍이라고 한다.
	  데이터형이 매개변수에 의해 표현되므로, 템플릿을 매개변수화 데이터형이라고도 한다.
*/