/*
	- STL은 일반화 프로그래밍의 한 예이다.
	  객체 지향 프로그래밍은 프로그래밍의 데이터 측면을 중시하는 반면에, 일반화 프로그램은 알고리즘에 중점을 둔다.
	- 두 프로그래밍 패러다임에 공통적인 것은, 데이터의 추상화와 재활용이 가능한 코드의 작성이다.
	- 일반화 프로그래밍의 목적은 데이터형과 무관한 코드를 작성하는 것이다. 템플릿은 일반화 프로그램을 작성하는 C++의 도구이다.
	  물론, 템플릿을 사용하여 함수나 클래스를 일반형으로 정의할 수도 있다.
	  그러나 STL은 알고리즘의 일반화된 표현을 제공함으로써 한걸음 더 나아간다.
	  템플릿을 가지고도 이것을 할 수 있지만, 세심하게 설계된 구성 요소를 추가하지 않고는 불가능하다.
	- STL = 템플릿 + 설계
*/
/*
	- 템플릿이 알고리즘을 저장할 데이터형과 무관하게 만드는 것처럼, 이터레이터는 알고리즘을 사용할 컨테이너형과 무관하게 만든다.

	- 두 개의 서로 다른 데이터 표현에 대해 하나의 find 함수를 구하는 방법

				double* find_ar(double* ar, int n, const double& val)
				{
					for(int i=0 ; i<n ; i++)
						if(ar[i] == val)
							return &ar[i];
					return 0;
				}
		: 이 함수는 인덱스 표기를 사용하여 배열을 훑고 지나가는데, 템플릿을 사용하면 == 연산자를 지원하는 모든 데이터형의 배열에까지 이것을 일반화할 수 있다.
		  그러나 이 알고리즘은 여전히 배열이라는 특정한 데이터 구조에 매여 있다.


				struct Node
				{
					double item;
					Node* p_next;
				};
				Node* find_ll(Node* head, const double& val)
				{
					Node* start;
					for(start = head ; start != 0 ; start = start->p_next)
						if(start->item == val)
							return start;
					return 0;
				}
		: 이 함수도 템플릿을 사용하면 == 연산자를 지원하는 모든 데이터형의 링크드 리스트에까지 이것을 일반화할 수 있다.
		  그러나 이 알고리즘은 여전히 링크드 리스트라는 특정한 데이터 구조에 매여 있다.

		: 구현의 세부를 들여다보면 두 find 함수가 서로 다른 알고리즘을 사용한다는 것을 알 수 있다.
		  이 경우에 일반화 프로그래밍의 목적은 배열, 링크드 리스트, 그 밖의 다른 컨테이너형 데이터 구조에 두루 사용할 수 있는, 하나의 find 함수를 확보하는 것이다.
		  즉, 그 함수는 컨테이너에 저장되는 데이터형에 얽매이지 않을 뿐만 아니라, 컨테이너의 구조 자체에도 얽매이지 않아야 한다.
		  컨테이너에 저장되는 데이터형에 대해 템플릿들이 일반화된 표현을 제공한다. 그 다음에 필요한 것은 컨테이너에 저장된 값들을 훑고 지나가는 과정의
		  일반화 표현이다. 이터레이터가 바로 그러한 일반화 표현이다.

		: find 함수를 구현하기 위해 이터레이터가 가져야 하는 특성들... (p, q는 이터레이터)
			1) 이터레이터가 참조하는 값에 접근하기 위해 내용 참조를 할 수 있어야 한다.		-> *p 정의
			2) 한 이터레이터를 다른 이터레이터에 대입할 수 있어야 한다.						-> p = q 정의
			3) 한 이터레이터가 다른 이터레이터와 같은 것인지 비교할 수 있어야 한다.			-> p == q, p != q 정의
			4) 이터레이터가 컨테이너에 들어 있는 모든 원소들을 훑고 지나갈 수 있어야 한다.	-> ++p, p++ 정의

				typedef double* iterator;
				iterator find_ar(iterator ar, int n, const double& val)
				{
					for(int i=0 ; i<n ; i++, ar++)
						if(*ar == val)
							return ar;
					return 0;
				}

		: 이제 함수 매개변수 리스트를 변경하여, 범위를 지정하는 매개변수로 배열의 시작을 지시하는 포인터와, 배열의 끝 바로 다음을 지시하는 포인터를 제공할 수 있다.

				typedef double* iterator;
				iterator find_ar(iterator begin, iterator end, const double& val)
				{
					iterator ar;
					for(ar = begin ; ar != end ; ar++)
						if(*ar == val)
							return ar;
					return end;				// val을 찾지 못했다는 것을 나타낸다. 
				}

		: find_ll()에 대해서는 *와 ++연산자를 정의하는 이터레이터 클래스를 정의할 수 있다.

				struct Node
				{
					double item;
					Node* p_next;
				};
				class iterator
				{
					Node* pt;
				public:
					iterator() : pt(0) { }
					iterator(Node* pn) : pt(pn) { }
					double operator*() 
					{ 
						return pt->item; 
					}
					iterator& operator++()			// ++it 위해
					{
						pt = pt->p_next;
						return *this;
					}
					iterator operator++(int)		// it++ 위해
					{
						iterator tmp = *this;
						pt = pt->p_next;
						return tmp;
					}
					operator==(), operator!=() 등.....
				}

				iterator find_ll(iterator head, const double& val)
				{
					iterator start;
					for(start = head ; start != 0 ; ++start)
						if(*start == val)
							return start;
					return 0;
				}

		: 두 함수가 검색 대상들의 끝에 도달했는지 판단하는 방법만 다르다.
			  find_ar() -> 끝 바로 다음을 지시하는 이터레이터를 사용한다.
			  find_ll() -> 마지막 노드에 저장된 널 값을 사용한다.
		  이 차이만 없앤다면 두 함수를 동일하게 만들 수 있다.
		  예를 들어, 링크드 리스트가 공식적인 마지막 원소 바로 다음에 비공식적인 원소를 하나 더 갖게 만들 수 있다.
		  즉, 배열과 링크드 리스트가 둘 다 하나의 past-the-end 원소를 갖게 만들면, 이터레이터가 past-the-end 위치에 도달했을 때 검색을 멈출 수 있다.
		  즉, find_ar()과 find_ll()은 같은 방법으로 데이터의 끝을 확인하므로 알고리즘이 동일해진다.			

	- STL은 위의 접근 방식을 그대로 따른다.
		: 먼저 각각의 컨테이너 클래스(vector, list, deque 등)들은 그 클래스에 맞는 이터레이터형을 정의한다.
		  어떤 컨테이너 클래스에 대해서는 포인터가 이터레이터가 될 수 있고, 다른 컨테이너 클래스에 대해서는 객체가 이터레이터가 될 수 있다.
		  구현이 무엇이든지 간에 이터레이터는 *나 ++와 같은 필요한 연산을 제공할 것이다.
		  그 다음에, 각 컨테이너 클래스는 컨테이너에 있는 마지막 값 바로 다음으로 증가되었을 때 이터레이터에 대입되는 값 past-the-end 마커를 가진다.
			=> begin(), end()

		: 컨테이너 클래스를 사용할 때 이터레이터가 어떻게 구현되어 있는지, past-the-end가 어떻게 구현되어 있는지 알 필요가 없다.
		  begin()이 첫 번째 원소를 지시하는 이터레이터를 리턴하고, end()가 past-the-end를 지시하는 이터레이터를 리턴한다는 사실만 알면 충분하다.

				vector<double>::iterator pr;
				for(pr = scores.begin() ; pr != scores.end() ; pr++)
					cout << *pr << endl;

				list<double>::iterator pr;
				for(pr = scores.begin() ; pr != scores.end() ; pr++)
					cout << *pr << endl;

			: pr을 위해 선언된 데이터형만 유일하게 바뀌었다. 따라서 각 클래스를 위한 적절한 이터레이터를 정의하고 클래스들을 일관된 방식으로 설계하면,
			  STL을 사용하여 내부적인 표현이 전혀 다른 여러 컨테이너들에 대해 동일한 코드를 작성할 수 있다.

		: 실제로 스타일의 문제로, 이터레이터를 직접 사용하는 대신, 사용자를 위해 세부를 처리해 주는 for_each()와 같은 STL 함수를 사용해야 한다.
*/

/*
	- 이터레이터의 종류
			1) 입력 이터레이터
			2) 출력 이터레이터
			3) 전방 이터레이터
			4) 전후방 이터레이터
			5) 임의 접근 이터레이터
		
				template<class InputIterator, class T>
				InputIterator find(InputIterator first, InputIterator last, const T& value);
				: 이것은 이 알고리즘이 입력 이터레이터를 요구한다는 뜻이다.

				template<class RandomAccessIterator>
				void sort(RandomAccessIterator first, RandomAccessIterator last);
				: 이것은 이 알고리즘이 임의 접근 이터레이터를 요구한다는 것을 뜻한다.

		: 다섯 가지 이터레이터 모두가 내용 참조를 할 수 있고(즉, 각 이터레이터에 맞게 * 연산자가 정의되어 있다.) 서로 같은지 비교할 수 있고, 서로 다른지 비교할 수 있다.
		  두 이터레이터가 같은 것으로 평가될 경우, 제1이터레이터를 이용한 내용 참조와 제2이터레이터를 이용한 내용 참조는 같은 값을 산출해야 한다.

	- 입력 이터레이터
		: 컨테이너에서 프로그램으로 들어가는 정보를 입력이라고 생각한다. 따라서 입력 이터레이터는, 컨테이너로부터 값을 읽기 위해 프로그램이 사용할 수 있다.
		  입력 이터레이터의 내용 참조는 프로그램이 컨테이너로부터 하나의 값을 읽는 것을 허용하지만, 프로그램이 그 값을 변경하는 것을 허용할 필요는 없다.
		  따라서 입력 이터레이터를 필요로 하는 알고리즘들은, 컨테이너에 저장된 값을 변경하지 않는 알고리즘들이다.
		: 입력 이터레이터를 사용하여 다시 한 번 그 컨테이너를 훑을 때 동일한 순서로 값들을 훑고 지나간다는 보장은 없다.
		  입력 이터레이터가 이미 증가된 후에 증가되기 전 값을 여전히 내용 참조할 수 있다는 보장은 없다.
				=> 입력 이터레이터에 기초를 둔 알고리즘은 일회성 알고리즘이다. 즉, 이전의 패스에서 얻은 이터레이터 값이나, 같은 패스라도 앞에서 얻은 이터레이터 값에 의존하지 않는다.
				   입력 이터레이터는 일방향 이터레이터이다. 즉 증가시킬 수는 있지만 되돌릴 수는 없다.

	- 출력 이터레이터
		: 프로그램에서 컨테이너로 정보를 보내기 위해 이터레이터가 사용된다는 것을 의미한다.
		  출력 이터레이터는 내용 참조를 통해 프로그램이 컨테이너에 있는 값을 읽는 것이 아니라 변경하는 것을 허용한다.
		  읽지는 못하지만 쓸 수 있다는 것이 이상하게 여겨지겠지만, 이 특성은 화면 출력에도 적용된다. 즉, cout은 디스플레이로 보내지는 문자들의 스트림을 변경할 수 있지만,
		  화면에 표시된 것들을 읽지 못한다. STL은 일반적이어서 컨테이너들이 출력 장치를 나타낼 수도 있다.

	=> 입력 이터레이터는 일회성 읽기 전용 알고리즘에 사용할 수 있고, 출력 이터레이터는 일회성 쓰기 전용 알고리즘에 사용할 수 있다.

	- 전방 이터레이터
		: 입력 이터레이터와 출력 이터레이터가 가지고 있는 모든 기능에 자체 기능을 추가한다.
		: 입력 이터레이터, 출력 이터레이터와 마찬가지로, 전방 이터레이터도 컨테이너 속을 훑고 지나가기 위해 ++ 연산자만 사용한다.
		  그래서 전방 이터레이터는 컨테이너 속을 한 번에 한 원소씩 전방으로만 진행할 수 있다.
		: 입력 이터레이터나 출력 이터레이터와는 달리, 전방 이터레이터는 그것을 사용할 때마다 연속된 값들을 반드시 같은 순서로 훑고 지나간다.
		  또한 전방 이터레이터가 증가된 후에도(따로 저장해 두었다면) 그 이전의 이터레이터 값을 내용 참조하여 항상 같은 값을 얻을 수 있다.
		  이 특성 때문에 다중 패스 알고리즘이 가능해진다.
		: 데이터를 읽기/변경 할 때와 데이터를 읽기만 할 때에도 전방 이터레이터를 사용할 수 있다.
				int* pirw;			// 읽기/쓰기 이터레이터
				const int* pir;		// 읽기 전용 이터레이터

	- 전후방 이터레이터
		: 전방 이터레이터가 가지고 있는 모든 기능에 두 감소 연산자(접두어 버전과 접미어 버전)에 대한 기능을 추가한다.

	- 임의 접근 이터레이터
		: 표준 정렬이나 이진 탐색과 같은 알고리즘은, 컨테이너에 들어 있는 임의 원소로 직접 점프할 수 있는 기능을 가지고 있어야 한다.
		  이것을 임의 접근이라 한다. 이 때 임의 접근 이터레이터가 필요하다.
		  임의 접근 이터레이터는 전후방 이터레이터가 가지고 있는 모든 기능에, 임의 접근을 지원하는(포인터 덧셈과 같은) 연산과, 원소들의 순서를
		  매기는 데 사용할 관계 연산자들을 추가한다.

	=> 여러 종류의 이터레이터가 존재하는 이유는 요구 사항이 가정 적은 이터레이터를 사용하여 알고리즘을 작성함으로써, 가장 넓은 범위의 컨테이너들에 사용할 수
	   있도록 하자는 것이 그 목적이다.
	   따라서 계층이 낮은 입력 이터레이터를 사용함으로써 find()는 읽을 수 있는 값들이 들어 있는 어떠한 컨테이너에도 사용할 수 있다.
	   그러나 임의 접근 이터레이터를 요구하는 sort()는 그러한 종류의 이터레이터를 지원하는 컨테이너에만 사용할 수 있다.

	=> 각 컨테이너 클래스는 iterator라는 클래스 사용 범위의 typedef 이름을 정의한다. 그래서 vector<int> 클래스는 vector<int>::iterator형의 이터레이터를 가진다.
	   그러나 이 클래스에 관련된 문건을 들여다보면, 벡터 이터레이터들이 임의 접근 이터레이터라고 되어 있다.
	   그것은 임의 접근 이터레이터가 이터레이터의 모든 기능을 가지고 있기 때문에, 그 알고리즘에는 어떠 종류의 이터레이터도 사용할 수 있다는 뜻이다.
	   마찬가지로 list<int> 클래스는 list<int>::iterator형의 이터레이터를 가진다. STL은 이중 링크드 리스트를 구현한다.
	   그래서 그것은 전후방 이터레이터를 사용한다. 그래서 임의 접근 이터레이터에 기초하는 알고리즘은 사용할 수 없지만, 그보다 요구 사항이 적은 이터레이터들에
	   기초하는 알고리즘은 사용할 수 있다.
*/

/*
	- 전방 이터레이터의 특성을 갖는 클래스를 설계할 수 있지지만, 컴파일러가 그 클래스만 사용하도록 제한할 수는 없다.
	  그 이유는 전방 이터레이터가 데이터형이 아니라 요구 사항들의 집합이기 때문이다.
	  사용자가 설계한 이터레이터 클래스를 통해 그 요구 사항들을 충족시킬 수 있다. 그러나 단순 포인터를 가지고도 그 요구 사항들을 충족시킬 수 있다.
	  STL 알고리즘은 그 요구 사항을 충족 시키는 어떠한 이터레이터 구현과도 잘 동작한다. STL을 설명하는 문건들은 그러한 요구 사항들의 집합을 개념이라는 단어로 표현한다.
	  따라서 입력 이터레이터 개념, 전방 이터레이터 개념 등으로 표현한다.
	  어쨋거나 설계하려는 컨테이너 클래스에 이터레이터가 필요하면, 표준 이터레이터 템플릿들을 포함시키는 STL에 의지할 수 있다.

	- 개념은 상곡과 비슷한 관계를 가질 수 있다. 예를 들어 전후방 이터레이터는 전방 이터레이터의 기능을 상속한다.
	  그러나 이터레이터에는 C++의 상속 메커니즘을 적용할 수 없다. 예를 들면, 전방 이터레이터를 클래스로 구현하고, 전후방 이터레이터를 단순 포인터로 구현할 수 있다.
	  이것을 C++ 언어로 표현하면, 이 특별한 전후방 이터레이터는 내장 데이터형이기 때문에 클래스로부터 파생시킬 수 없다. 그러나 개념적으로는 기능을 상속한다.
	  어떤 STL 문건에서는 이와 같은 개념적인 상속을 개량이라는 단어로 표현한다.
	  따라서 전후방 이터레이터는 전방 이터레이터 개념의 개량이다.

	- 어떤 개념의 특별한 한 구현을 모델이라고 한다.
	  따라서 int를 지시하는 단순 포인터는 임의 접근 이터레이터 개념의 한 모델이다. 또한 그것은 전방 이터레이터 개념의 모든 요구 사항을 충족시키기 때문에,
	  전방 이터레이터 개념의 모델이기도 하다.
*/

/*
	- 이터레이터는 포인터를 일반화한 것이다. 그리고 포인터는 이터레이터의 모든 요구 사항을 충족시킨다. 이터레이터는 STL 알고리즘을 위한 인터페이스를 구성한다.
	  그리고 포인터는 이터레이터이다. 따라서 STL 알고리즘은 포인터에 기초를 두고 있는 STL이 아닌 컨테이너들에 포인터를 적용할 수 있다.
	  예를 들면, 배열에 STL 알고리즘을 사용할 수 있다.
	  Receipts가 double 값들의 배열이라면 그것을 오름차순으로 정렬할 수 있다.

			const int SIZE = 100;
			double Receipts[SIZE];

			sort(Receipts, Receipts + SIZE);

		: Receipts는 첫 번째 원소의 주소이고, Receipts+SIZE는 배열의 마지막 원소 바로 다음에 있는 원소의 주소이다.
		: C++는 Receipts + n의 결과가 배열 범위에 있거나 배열이 마지막 원소 바로 다음을 지시하는 한, 그 수식이 정의된다고 보장한다.
		  그래서 C++는 포인터들을 위한 "마지막 원소 바로 다음" 이라는 개념을 배열에도 지원한다.
		  이것이 STL 알고리즘을 일반 배열에 적용하는 것을 가능하게 만든다. 그러므로 포인터가 이터레이터이고, 알고리즘들이 이터레이터에 기초하고 있기 때문에,
		  STL 알고리즘을 일반 배열에 적용할 수 있다.
		  마찬가지로 적절한 이터레이터(포인터 또는 객체일 수도 있다)와 past-the-end 마커를 제공한다면, STL 알고리즘을 사용자가 설계하는 데이터 형식에 적용할 수 있다.
*/

/*
	- STL은 미리 정의되어 있는 이터레이터를 몇 가지 제공한다. -> ostream_iterator, istream_iterator
		
				inst casts[10] = { 6, 7, 2, 9, 4, 11, 8, 7, 10, 5 };
				vector<int> dice[10];
				
				copy(casts, casts + 10, dice.begin());

		: copy()라는 알고리즘은 이터레이터들로 표현된다. 그래서 한 종류의 컨테이너에서 다른 종류의 컨테이너로, 또는 배열을 훑고 지나가는 포인터를
		  이터레이터로 사용할 수 있으므로 배열로부터 또는 배열에 복사할 수도 있다.
		: 두 매개변수는 입력 이터레이터여야 하고, 마지막 매개변수는 출력 이터레이터여야 한다. 그리고 목적지 컨테이너는 복사되는 원소들을 저장할 수 있을 만큼 충분히 커야한다.

		: 정보를 디스플레이에 복사하려 한다고 가정하자. 출력 스트림을 나타내는 이터레이터가 있다면, copy()를 사용할 수 있다.
		  STL은 ostream_iterator 템플릿을 통해 그러한 이터레이터를 제공한다. STL 방식으로 말하면, 이 템플릿은 출력 이터레이터 개념의 모델이다.
		  또한 그것은 다른 어떤 인터페이스를 STL이 사용하는 인터페이스로 변환하는 클래스나 함수인, 어댑터의 한 예이다.
		  iterator 헤더파일을 포함시키고 다음과 같이 선언함으로써, 이러한 종류의 이터레이터를 만들 수 있다.

					#include <iterator>
					...
					ostream_iterator<int, char> out_iter(cout, " ");

			: out_iter 이터레이터는 cout을 사용하여 정보를 출력할 수 있게 해주는 인터페이스가 된다.
				첫 번째 템플릿 매개변수(int)는 출력 스트림으로 보내는 데이터형을 나타낸다. 두 번째 템플릿 매개변수(char)는 출력 스트림이 사용하는 문자형을 나타낸다.
				첫 번째 생성자 매개변수(cout)는 사용할 출력 스트림을 나타낸다. 파일 출력에 사용되는 스트림이 첫 번째 생성자의 매개변수가 될 수도 있다.
				두 번째 문자열 매개변수는 출력 스트림에 보내진 각 항목 뒤에 표시되는 분리자이다.
			
			: ostream_iterator를 다음과 같이 사용할 수 있다.

					*out_iter++ = 15;		// cout << 15 << " "; 처럼 동작한다.
				
					-> 단순 포인터의 경우에, 이 구문은 15라는 값을 지시된 위치에 대입한 다음, 포인터를 증가시킨다.
					   그러나 ostream_iterator의 경우에, 이 구문은 15와 빈칸 문자 하나로 이루어진 문자열을 cout이 관리하는 출력 스트림에 보내고 나서, 출력 연산을 준비해야 한다.
				  
			: ostream_iterator를 copy()에 다음과 같이 사용할 수 있다.

					copy(dice.begin(), dice.end(), out_iter);

					-> 이 구문은 dice 컨테이너의 전체 범위, 즉 dice 컨테이너의 내용을 출력 스트림에 복사하는 것을 의미한다.

			: 익명 이터레이터를 만들 수도 있다. 즉, 다음과 같은 어댑터를 사용할 수 있다.

					copy(dice.begin(), dice.end(), ostream_iterator<int, char>(cout, " "));

		: 같은 논리로, iterator 헤더 파일은 istream 입력을 이터레이터 인터페이스에 맞게 개량하기 위한 istream_iterator 템플릿을 정의한다.
		  이것은 입력 이터레이터 개념의 모델이다. 두 개의 istream_iterator 객체를 정의하여, copy()에 입력 범위를 지정해 줄 수 있다.

					copy(istream_iterator<int, char>(cin), istream_iterator<int, char>(), dice.begin());

			: ostream_iterator와 마찬가지로, istream_iterator도 두 개의 템플릿 매개변수를 사용한다. 첫 번째 템플릿 매개변수는 읽을 데이터형을 나타낸다.
			  두 번째 템플릿 매개변수는 입력 스트림에 사용되는 char 데이터형을 나타낸다.
			  생성자 매개변수로 cin을 사용하는 것은, cin이 관리하는 입력 스트림을 사용한다는 뜻이다.
			  생성자 매개변수를 생략하는 것은 입력 실패를 나타낸다. 그래서 위의 코드는 파일 끝, 데이터형 불일치 또는 다른 어떤 입력 실패가 일어날 때까지
			  입력 스트림으로부터 데이터를 읽는다는 뜻이다.
*/

/*
	- 기타 유용한 이터레이터들
		: 이 이터레이터들은 STL 알고리즘의 일반성을 높인다.
				1) reverse_iterator
				2) insert_iterator
				3) back_insert_iterator
				4) front_insert_iterator

	- reverse_iterator
		: reverse_iterator를 증가시키면 본질적으로는 그것을 감소시킨다.
		  보통의 이터레이터를 사용하여 감소시키지 않는 이유는 기본 함수들의 사용을 단순화하기 위해서이다.

				ostream_iterator<int, char> out_iter(cout, " ");
				copy(dice.begin(), dice.end(), out_iter);			// 전진으로 출력

				copy(dice.rbegin(), dice.rend(), out_iter);			// 후진으로 출력

			: vector 클래스는 past-the-end를 지시하는 reverse_iterator를 리턴하는 rbegin()과 첫 번째 원소를 지시하는 reverse_iterator를 리턴하는 rend()를 가지고 있다.
			  reverse_iterator를 증가시키면 실제로는 감소되기 때문에, 컨테이너의 내용을 뒤집어 출력할 수 있다.
			  그리고 reverse_iterator는 선언할 필요조차 없다.

		: 역방향 포인터의 사용은 특별한 보상을 요구한다. 
		  rp가 dice.rbegin()으로 초기화되는 역방향 포인터라고 가정하자. 그렇다면 *rp는 dice.rbegin()이 리턴하는 past-the-end의 주소의 내용을 참조하려 시도하기 때문에 안 된다.
		  마찬가지로 rend()가 실제로 첫 번째 원소의 위치라면, 범위의 끝이 복사 범위에 포함되지 않기 때문에 copy()는 한걸음 일찍 복사를 멈춘다.
		  역방향 포인터들은 먼저 감소시킨 후에 내용 참조를 함으로써 이 두 가지 문제를 해결한다.
		  즉, *rp는 *rp의 현재 값 바로 앞에 있는 이터레이터 값을 내용 참조한다.
		  즉, rp가 여섯 번째 위치를 지시한다면, *rp는 다섯 번째 위치의 값이 된다. 
*/

#include <iostream>
#include <iterator>
#include <vector>

int main()
{
	using namespace std;

	int casts[10] = { 6, 7, 2, 9, 4, 11, 8, 7, 10, 5 };
	vector<int> dice(10);
	
	copy(casts, casts + 10, dice.begin());
	cout << "주사위를 던져라!\n";

	ostream_iterator<int, char> out_iter(cout, " ");
	copy(dice.begin(), dice.end(), out_iter);
	cout << endl;

	cout << "역방향 이터레이터의 암시적 사용:\n";
	copy(dice.rbegin(), dice.rend(), out_iter);
	cout << endl;

	cout << "역방향 이터레이터의 명시적 사용:\n";
	vector<int>::reverse_iterator ri;
	for (ri = dice.rbegin(); ri != dice.rend(); ++ri)
		cout << *ri << ' ';
	cout << endl;

	return 0;
}

/*
	- 이터레이터를 명시적으로 선언하는 방법과, rbegin()의 리턴값을 함수에 전달하여 그 문제를 내부적으로 처리하는 STL 함수를 사용하는 방법 중에서
	  선택해야 한다면, STL함수를 사용해야 한다.
	  => 실수 줄임...
*/

