/*
	< 절차적 프로그래밍 방식 >
	- 처리해야 할 절차에 우선적으로 초점을 맞추고, 그러고 나서 데이터를 표현할 방법을 찾는다.

	< OOP >
	- 객체를 서술하는 데 필요한 데이터와, 사용자가 그 데이터를 다루는 방법에 대해 생각하면서, 사용자가 이해하는 방식대로 객체에 초점을 맞춘다.
	  이러한 인터페이스를 설계하고 난 후, 인터페이스와 데이터 저장 형태를 구현하는 것으로 나아간다.

	< 추상화 >
	- 정보를 사용자 인터페이스로 표현하는 것.
	  어떤 문제에 대해 필수적인 조작적 기능들을 추상화하고, 그것으로 해결책을 표현하는 것.
	  추상화를 통해서 사용자 정의 데이터형으로 나아간다.
	  C++에서는 클래스가 추상화 인터페이스를 구현하는 사용자 정의 데이터형이다.

	< 데이터형 >
	- 그것을 대상으로 수행할 수 있는 연산에 의해 정의된다.
	  어떤 변수를 int형으로 선언하거나 float형을 지시하는 포인터로 선언한다고 할 때, 그러한 선언은 단지 메모리만 대입하는 것이 아니라,
	  그 데이터형으로 수행할 수 있는 연산까지도 함께 정의되는 것이다.
	- 내장된 기본 데이터형의 경우, 동작에 관한 정보들이 컴파일러에 내장된다
	  그러나 사용자 정의 데이터형을 정의한다면, 프로그래머가 이와 같은 정보를 직접 제공해야 한다.

	< 클래스 >
	- 추상화를 사용자 정의 데이터형으로 변환해 주는 C++의 수단이다.
	  클래스는 데이터 표현과 데이터를 조작하는 메서드들을 하나의 패키지 안에 결합한다.
	   
	< 클래스 서술 >
	- step1) 클래스 선언 -> 데이터 멤버와 public 인터페이스, 멤버함수를 이용하여 데이터 표현을 서술한다.
						   (클래스의 개요를 제공)
	- step2) 메서드 정의 -> 클래스 멤버함수가 어떻게 구현되는지를 서술한다.
						   (세부 사항을 제공)

	< 인터페이스 >
	- 두 시스템 간의 상호 작용을 위한 공통된 프레임워크
	- 프로그램 인터페이스는, 사용자의 의도를 컴퓨터에 저장되어 있는 특정 정보로 변환하는 것을 담당한다.

	< 추상화 -> 캡슐화 >
	- 클래스 설계는 public 인터페이스와 세부적인 구현을 분리하려고 노력한다.
	  이 때, public 인터페이스는 설계의 추상화를 나타낸다.
	- 세부적인 구현들을 따로 결합하여 추상화와 분리하는 것을 캡슐화라고 한다.
		ex1) 데이터 은닉(데이터를 클래스의 private 부분에 넣는 것)
			 -> private 부분에 있는 정보는 public 멤버함수를 통해서만 접근 가능하다.
			 -> 데이터에 직접 접근하지 못하게 막아 줄 뿐만 아니라, 데이터 표현이 어떻게 되어있는지에 대해
			    클래스 사용자가 신경 쓰지 않도록 해 준다.
		ex2) 클래스 함수들의 정의를 클래스 선언과 독립된 파일에 넣는 것	

	< 정리 >
	1. 클래스
		: 사용자 정의 데이터형의 정의 이다.
		: 클래스 선언은 데이터를 저장하는 방법과 데이터들에 접근하여 그들을 조작하는 데 사용할 수 있는 메서드들을 서술한다.
	2. 추상화
		: 클래스는 클래스 메서드의 public 인터페이스를 통해 클래스 객체를 대상으로 수행할 수 있는 연산자들을 서술한다.
	3. 은닉
		: 클래스는 데이터 멤버들에 대해 private를 사용하여, 멤버 함수를 통해서만 그 데이터에 접근할 수 있다.
	4. 캡슐화
		: 데이터 표현과 메서드 코드와 같은 세부 구현은 사용자에게 은닉되어 있다.

	< 객체 생성 >
	- 어떤 클래스의 두 객체를 생성할 때, 생성된 각 객체는 자체의 내부적인 변수들(즉, 클래스 멤버들)을 위한 저장 공간을 가진다.
	  그러나 같은 클래스에 속하는 모든 객체들은, 클래스 메서드들이 한 카피씩 모여서 구성된 동일한 클래스 메서드 집합을 공유한다.
	- 멤버함수를 호출한다는 말은, 다른 OOP 언어에서 메시지를 보낸다는 말과 같은 뜻이다.
	  그러므로, 두 개의 서로 다른 객체에 같은 메시지를 보낸다는 말은, 같은 메서드를 호출하여 그것을 두 개의 서로 다른
	  객체에 적용한다는 말과 같은 것이다.
*/

/*
	< 생성자 >
	- 그 클래스의 객체가 생성될 때마다 호출되는 특별한 종류의 클래스 멤버 함수이다.
	- C++가 내세우는 목표 중의 하나는, 클래스 객체를 표준 데이터형을 사용하듯이 사용할 수 있게 만드는 것이다.
	  그러나 클래스의 데이터들은 private 접근 제어를 가지고 있어 표준 데이터형 처럼 초기화 할 수 없다.
	  이 문제를 해결하기 위해 C++는, 새로운 객체를 생성하고 그들의 데이터 멤버에 값을 대입해 주는 클래스 생성자라는 특별한 멤버 함수를 제공한다.
	- 생성자는 객체를 선언할 때 프로그램이 자동으로 호출한다.

	- 생성자의 선언, 정의, 사용

		: 선언 (디폴트 매개변수를 사용하는 생성자의 원형)
			Stock(const string& co, long n = 0, double pr = 0.0);

		: 정의
			Stock::Stock(const string& co, long n, double pr)
			{
				company = co;
				if(n<0)
				{
					std::cerr << "주식 수는 음수가 될 수 없으므로, " << company << " shares를 0으로 설정합니다.\n";
					shares = 0;
				}
				else
					shares = n;
				share_val = pr;
				set_tot();
			}

		: 사용
		  : 생성자가 객체를 만드는 일을 끝내기 전까지는 객체가 없는 상태이므로, 생성자 호출에 객체를 사용할 수 없다.
			생성자는 객체에 의해 호출되는 것이 아니라, 객체를 생성하는 데 사용된다.
			  1) 명시적 호출
					Stock garment = Stock("Furry Mascon", 50, 2.5);
			  2) 암시적 호출
					Stock garment("Furry Mascon", 50, 2.5);
			  3) 동적 메모리 대입을 위한 호출
					Stock* pstock = new Stock("Furry Mascon", 50, 2.5);		// 이 경우, 객체가 이름을 가지고 있지 않다.

	< 디폴트 생성자 >
	- 사용자가 어떠한 생성자도 정의하지 않을 경우에만 컴파일러가 디폴트 생성자를 제공한다.

	- 생성자의 선언, 정의, 사용
		: 선언
			Stock();
		: 정의(두 가지 방법)
			: 두 가지 방법 중 사용자는 하나의 디폴트 생성자만 가질 수 있다. -> 두 가지 방법을 다 사용하여 두 개의 디폴트 생성자를 만들면 안 된다.
				1) 모든 매개변수에 디폴트 값을 제공하는 것.
					Stock(const string& co = "Error", int n = 0, double pr = 0.0);
				2) 함수 오버로딩을 사용하여 매개변수가 없는 또 하나의 생성자를 정의 하는 것.
					Stock::Stock()
					{
						company = "no name";
						shares = 0;
						share_val = 0;
						total_val = 0;
					}
		: 사용
			1) 명시적 호출
				Stock first = Stock();
			2) 암시적 호출
				Stock first;
			3) 동적 메모리 대입을 위한 호출
				Stock* pFirst = new Stock;

	- 주의
		: 실수로 디폴트 생성자가 아닌 생성자의 암시적인 형식을 지정하면 안 된다.
		: 디폴트 생성자를 암시적으로 호출할 때는 괄호를 사용하면 안 된다.

	< 파괴자 >
	- 객체의 수명이 끝나는 시점에서, 프로그램은 파괴자를 특별한 멤버 함수를 자동으로 호출한다.
	- 파괴자가 호출되는 시점은 컴파일러가 결정한다.
	- 클래스에는 반드시 파괴자가 있어야 한다. 사용자가 파괴자를 제공하지 않으면, 컴파일러가 디폴트 파괴자를 선언한다.

	< const 멤버 함수 >
	- 필요할 때 함수의 형식 매개변수로 const 참조와 const 포인터를 사용해야 하듯이,
	  호출 객체를 변경하면 안 되는 클래스 메서드들은 const로 만들어야 한다.
		void show() const;			// const멤버 함수 선언 -> 호출 객체를 변경하지 않는다고 약속한다.
		void Stock()::show() const	// 정의 부분에도 const를 붙여준다.

	< this >
	- 하나의 메서드가 두 개의 객체를 동시에 처리할 필요가 있다.
	  그것을 가능하게 하기 위해서 C++는 this라는 특별한 포인터를 제공한다.
	- this 포인터는 멤버 함수를 호출하는 데 사용된 객체를 지시한다.
	- 기본적으로 this는 그 메서드에 숨은 매개변수로 전달된다.
	- 일반적으로, 생성자와 파괴자를 포함한 모든 클래스 메서드들은 그 메서드를 호출하는 객체의 주소로 설정되는 하나의 this포인터를 갖는다.
	- 호출한 객체를 메서드가 전체적으로 참조할 필요가 있을 경우에는, *this를 사용할 수 있다.
*/

/*
	< 객체 배열 >
	- 객체 배열의 선언과 초기화는 표준 데이터형의 배열의 방식과 같다.
	- 각각의 원소에 대해 생성자를 호출하여 초기화 한다.
		const int STKS = 4;
		Stock stocks[STKS] = {
			Stock("NanoSmart", 12.5, 20),
			Stock(),
			Stock("Boffo Objects", 200, 2.0),
			Stock("Monolithic Obellisks", 130, 3.25)
		};
	- 객체들의 배열을 초기화하는 이 방식은 처음에 디폴트 생성자를 사용하여 배열의 원소들을 생성한다.
	  그런 다음 중괄호 안에 있는 생성자들이 임시 객체를 생성하고, 그 내용을 배열 원소에 복사한다.
	  그러므로 클래스 객체들의 배열을 생성하려면 클래스가 하나의 디폴트 생성자를 가져야 한다.
*/

/*
	< 클래스 사용 범위 >
	- 멤버 함수들을 정의할 때에는 사용 범위 결정 연산자를 사용해야 한다.
		void Stock::update(double price) 
		{
			...
		}
	- 클래스 멤버 이름을 사용할 때에는 상황에 따라 직접 멤버 연산자(.)나 간접 멤버 연산자(->) 또는 사용 범위 결정 연산자(::)를 사용해야 한다.

	< 클래스 사용 범위 상수 >
	- 모든 객체들이 공유하는 하나의 상수를 만들기 위한 잘못된 방법
		class Stock
		{
		private:
			const int Months = 12;
			double costs[Months];
			...
		}
	  위 코드는 실패함 -> 클래스를 선언하는 것은 객체가 어떻게 생겼는지 서술하는 것이지, 그 객체를 생성하는 것은 아니기 때문이다.
						 따라서 값을 저장할 기억 공간은 객체가 생성될 때까지 마련되지 않는다.
	
	- 올바른 방법 두 가지
	1. 클래스 안에 열거체 선언
		class Bakery
		{
		private:
			enum { Months = 12; }
			double consts[Months];
			...
		}
	  열거체를 선언하는 것은, 클래스 데이터 멤버를 생성하지 않는다. 
	2. static 사용
		class Bakery
		{
		private:
			static const int Months = 12;
			double consts[Months];
			...
		}
	  static 멤버는 객체 안이 아니라 다른 정적 변수들과 함께 저장되는 Months라는 하나의 상수를 생성한다.
	  그래서 모든 Bakery 객체들이 하나의 Months 상수를 공유한다.
*/

/*
	< 추상화 데이터형 - Abstract Data Type >
	- ADT는 언어나 시스템의 세부적인 것들을 따지지 않고, 데이터형을 일반적으로 서술하는 것이다.
	- 클래스를 사용하는 것은 ADT를 구현할 수 있는 좋은 방법이다.
	- 스택 ADT
		# 빈 스택을 생성할 수 있다.
		# 스택의 꼭대기에 항목을 추가할 수 있다.
		# 스택의 꼭대기에서 항목을 삭제할 수 있다.
		# 스택이 가득 차 있는지 검사할 수 있다.
		# 스택이 비어 있는지 검사할 수 있다.
	- 클래스로 ADT 구현
		: public 멤버 함수들로 스택 연산을 나타내는 인터페이스를 제공하는 클래스를 선언한다.
		: public 인터페이스는 private의 내용을 드러내지 않고, '스택을 생성한다.' '항목을 푸시한다.' 등의 일반적인 용어로 표현해야 한다.
		: 스택 데이터의 저장은 private 데이터 멤버들이 담당한다.

		
*/