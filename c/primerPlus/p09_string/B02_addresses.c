/*
	- const char arr[] = "Somthing is pointing at me.";
		
		: 일반적으로, 큰따옴표로 둘러싸인 문자열은 실행 파일의 일부인 데이터 세그먼트에 저장된다.
		  프로그램이 메모리에 적재될 때 그 문자열도 함께 적재된다.
		  이때 큰따옴표로 둘러싸인 문자열은 정적 메모리에 있다고 말한다.
		  그러나 그 배열을 위한 메모리 할당은 프로그램의 실행이 시작된 후에 이루어진다.
		  그 시점에서, 큰따옴표로 둘러싸인 문자열이 그 배열에 복사된다.
		  그때부터 컴파일러는, 이름 arr은 첫 번째 배열 원소의 주소인 &arr[0]의 동의어로 인식한다.
		
		: 배열 형식에 사용된 arr은 주소 상수이다. arr을 변경한다는 것은 배열이 저장된 위치(주소)를 변경한다는 것을
		  의미하기 때문에 허용되지 않는다.
		  배열에 있는 다음 원소를 나타내는 arr+1 과 같은 연산은 사용할 수 있지만 ++arr은 허용되지 않는다.
		  증가 연산자는 상수가 아니라 변수 이름(수정 가능한 좌변값)에만 사용할 수 있다.

	- const char *pt = "Somthing is pointing at me.";

		: 포인터 형식도 그 문자열을 29개의 원소로 정적 메모리에 저장한다.
		  프로그램이 실행을 시작하면, 포인터 변수 pt를 위한 기억 위치를 하나 더 할당받고, 그 변수에
		  그 문자열의 주소를 저장한다. 처음에 이 변수는 그 문자열의 첫 번째 원소를 가리킨다. 그러나 그것은 변경할 수 있다.
		  그러그모 **pt 를 사용할 수 있다.

		: 문자열 리터럴은 const 데이터로 간주된다. pt가 데이터를 가리키기 때문에 const 데이터를 가리키고 있다고 선언되어야 한다.
		  이것은 pt의 값(즉 이것이 무엇을 가리키고 있는가)를 변경할 수 없다는 것은 아니고, pt를 사용해 데이터 자체의 값을
		  바꿀 수 없다는 뜻이다.

	- 요약
		
		: 배열의 초기화는 정적 메모리에서 배열로 그 문자열을 복사한다.
		  반면에 포인터의 초기화는 문자열의 주소만을 복사한다.
*/

#include <stdio.h>
#define MSG "I'm special." 

int main()
{
	char ar[] = MSG;
	const char* pt = MSG;

	printf("address of \"I'm special\": %p \n", "I'm special.");
	printf("              address ar: %p \n", ar);	// 얘만 주소 다름. - 정적인 데이터에 사용된 메모리의 부분은 ar에 사용된 메모리 즉 동적메모리에 사용된 것과는 다른다.
	printf("            a address pt: %p \n", pt);
	printf("          address of MSG: %p \n", MSG);
	printf("address of \"I'm special\": %p \n", "I'm special.");

	// 컴파일러는 특정 문자열을 단일 저장위치에 여러번 나타내도록 선택할 수 있다.
	return 0;
}