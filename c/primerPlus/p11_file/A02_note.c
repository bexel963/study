/*
	- int ungetc(int c, FILE *fp)
		: c가 나타내는 문자를 입력 스트림에 다시 반납한다.
		  사용자가 하나의 문자를 입력 스트림에 반납하면, 표준 입력 함수의 다음 번 호출은 그 문자를 읽는다.
		  한 번에 하나의 반납만 보장한다.
		: ex) 다음 콜론이 나타날 때까지 (콜론은 포함하지 않고) 문자들을 읽는 함수를 원한다고 가정할 때 getchar() or getc()를 이용하여
		      콜론을 읽을 때가지 문자들을 읽고, ungetc()를 사용하여 콜론은 다시 입력 스트림에 반납할 수 있다.

	- int fflush(FILE* fp)
		: 출력 버퍼에 아직 남아있는 데이터를 fp가 가리키는 출력 파일로 보낸다. (버퍼 비우기)
		  fp가 널 포인터면, 모든 출력 버퍼들을 비운다.

	- int setvbuf(FILE* restrict fp, char* restrict buf, int mode, size_t size)
		: 표준 입출력 함수들이 사용할 또 하나의 버퍼를 설정한다.
		  이 함수는 파일을 열고 난 후 그 스트림에 어떤 다른 조작이 가해지기 전에 호출된다.
		  fp	-> 스트림
		  buf	-> 사용할 버퍼
			: buf의 값으로 NULL을 사용하지 않는다면, 사용자가 버퍼를 만들어야 한다.
			  ex) 1024개의 char형으로 이루어진 배열을 선언하고, 그 배열의 주소를 전달할 수 있다.
			  그러나 buf의 값으로 NULL을 사용한다면, 함수가 직접 버퍼를 할당한다.
		  size	-> 배열의 크기가 얼마인지 setvbuf()에게 알려준다.
		  mode	-> 버퍼 종류를 설정한다.
			: _IOFBF -> 완전 버퍼링 (버퍼가 가득 찼을 때 버퍼를 비운다.)
			  _IOLBF -> 라인 버퍼링 (버파가 가득 찼거나 개행이 쓰여졌을 때 버퍼를 비운다.)
			  _IONBF -> 비 버퍼링 (버퍼를 사용하지 않는다.)
		: 이 함수는 성공하면 0을 리턴하고, 실패하면 0이 아닌 값을 리턴한다.

	- fread(), fwrite()
		: 일반적인 표준 입출력 함수들은, 문자와 문자열을 다루는 텍스트 지향적이다.
		  수치 데이터를 파일에 저장하기 위해 fprintf()를 쓸 수 있으나 이 함수는 수치값을 문자 데이터로 변환하는데, 이때 값이 변할 수 있다.
		  가장 정확하고 일관되게 수를 저장하는 방법은 프로그램이 사용하는 비트 패턴과 동일한 비트 패턴을 사용하는 것이다.
		  ex) double형 값은 double형 크기 하나의 단위로만 저장되어야 한다.
		: 프로그램에서 사용하는 표현과 동일한 표현으로 데이터를 파일에 저장할 때, 그 데이터가 바이너리 형태로 저장된다고 말한다.
		  수치가 문자 시퀀스로 변환되는 일이 일어나지 않는다.
		: 실제로는 모든 데이터가 바이너리 형태로 저장된다. 문자들도 그 문자 코드의 바이너리 표현을 사용하여 저장된다.
		  그러나 파일에 있는 모든 데이터가 문자 코드로 해석된다면, 그 파일이 텍스트 테이터를 가지고 있다고 말한다.
		  데이터의 일부 또는 전체가 바이너리 형태의 수치 데이터로 해석된다면, 그 파일이 바이너리 데이터를 가지고 있다고 말한다.
		  (또한 데이터가 기계어 명령들인 파일들은 바이너리 파일이다.)

		: int num = 12345;						// 12345를 num에 바이너리 수로 저장한다.
		  fprintf(fp, "%d", num);				// 문자들 '1', '2', '3', '4', '5'에 해당하는 바이너리 코드를 파일에 쓴다.
		  fwrite(&num, sizeof(int), 1, fp);		// 값 12345에 해당하는 바이너리 코드를 파일에 쓴다.

	- size_t
		: size_t형은 새로운 데이터형이 아니라 부호 없는 정수형이다.
		  size_t형은 유도된 정수형이다.
		  이식 가능한 데이터형(int32_t 등)과 마찬가지로, size_t형도 표준 데이터형에 의해 정의된다.
		  이 데이터형은 sizeof 연산자에 의해 리턴되는데 일반적으로 unsigned int형이다.
		  그러나 컴파일러에 따라 다른 데이터형이 될 수도 있다.
		  C의 헤더 파일 시스템은 typedef을 사용하여 size_t를 어떤 시스템에서는 unsigned int형에 대한 별명으로 만들고,
		  다른 시스템에서는 unsigned long형에 대한 별명으로 만들 수 있다.
		  그러므로 size_t형을 사용할 때, 컴파일러는 그것을 사용자 시스템에서 동작하는 표준 데이터형으로 대체할 것이다.
		  size_t형 값을 출력하기 위한 printf() 지정자로 %zd를 제공한다.

	- size_t fwrite(const void* restrict ptr, size_t size, size_t nmemb, FILE* restrict fp)
		: ptr	-> 저장할 데이터 덩어리의 주소
		  size	-> 저장할 그 데이터 덩어리들의 크기(바이트 단위)
		  nmeb	-> 저장할 데이터 덩어리들의 수
		  fp	-> 그 데이터가 저장될 파일

		: 크기가 256바이트인 데이터 덩어리 하나를 buffer로부터 파일로 저장.
			  char buffer[256];
			  fwrite(buffer, 256, 1, fp);

		: 10개의 데이터 덩어리를 earnings 배열로 부터 파일로 저장. 이 때 각각의 데이터 덩어리는 double형의 크기를 가진다.
			double earnings[10];
			fwrite(earnings, sizeof(double), 10, fp);

		: 이 함수는 성공적으로 저장한 항목의 수를 리턴한다. 일반적으로는 nmemb와 같다.

	- size_t fread(void* restrict ptr, size_t size, size_t nmemb, FILE* restrict fp)
		: ptr	-> 파일로부터 읽은 데이터를 저장할 메모리 공간의 주소
		  fp	-> 데이터를 읽을 파일
		: fwrite()를 사용하여 파일에 저장된 데이터를 다시 읽기 위해 이 함수를 사용할 수 있다.
		: 이 함수는 성공적으로 읽은 항목의 수를 리턴한다.

	- int feof(FILE* fp), int ferror(FILE* fp)
		: 표준 입력 함수들이 EOF를 리턴할 때, 일반적으로 이것은 파일의 끝에 도달했다는 것을 의미한다.
		  그러나 그것은 읽기 에러가 발생했다는 것을 의미할 수도 있다.
		  이 두 함수를 사용하면 이 두 가지 가능성을 구별할 수 있다.
		: feof()는 마지막 입력 호출에서 파일의 끝을 만나면 0이 아닌 값을 리턴한다. (안 만나면 0 리턴)
		: ferror()는 읽기 에러나 쓰기 에러가 발생하면 0이 아닌 값을 리턴한다. (에러 발생 안 하면 0 리턴)
*/