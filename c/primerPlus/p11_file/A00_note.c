/*
	- 프로그램-파일 커뮤니케이션
		1. 파일 리디렉션
		2. 특별한 입출력 함수들을 사용하여 파일로부터 데이터를 읽거나 파일에 데이터를 쓸 수 있도록, 프로그램 안에서 파일을 열기

	- 파일
		: 이름이 붙어 있는 디스크 상의, 즉, 솔리드 스테이트 디바이스(고체 전기가 흐르는 전자 디바이스된 고체 상태 장치)의 어떤 영역.
		: 운영체제 입장에서 볼 때 파일의 구조는 복잡하지만, 프로그래머의 관심사는 파일이 C프로그램에 어떻게 보이느냐는 것이다.
		  C는 파일을, 각 바이트를 개별적으로 읽을 수 있는, 연속적인 바이트들의 시퀀스로 인식한다.
		  ANSI C는 파일을 두 가지 인식 형식을 제공한다. - 텍스트 인식, 바이너리 인식

	- 텍스트 모드와 바이너리 모드
		: 모든 파일 컨텐츠는 바이너리 형태(0, 1)이다. 그러나 만일 파일이 C문자열만큼 많은 문자를 표현하기 위해 캐릭터용으로 2진코드를 사용한다면,
		  (EX. ASCII OR UNICODE) 그것은 텍스트 파일이다. 즉, 텍스트 파일은 텍스트가 있는 것이다.
		  파일 안에 있는 2진 값들이 기계어 코드 또는 수치 데이터(같은 내부 표현을 사용하는, long이나 double값에 사용되는) 또는 이미지나 음악 인코딩을
		  표현한다면 컨텐츠는 바이너리이다.
		: Unix는 두 종류의 컨텐츠에 같은 파일 포맷을 사용한다.
		: 텍스트 파일을 처리하기 위한 일부 규칙을 가져오기 위해, C는 파일에 엑세스하는 두 가지 방식, 즉 텍스트 모드와 바이너리 모드를 제공한다.
		  바이너리 모드에서, 프로그램은 파일의 각 바이트에 그리고 모든 바이트에 접근할 수 있다. 
		  그러나 텍스트 모드에서는 프로그램이 인식하는 내용과 파일에 있는 내용이 다를 수 있다.
		  텍스트 관점에서는, 그러한 것들의 지역 환경의 표현이 한 파일을 읽을 때 라인끝이나 파일끝이 C관점에서 맵핑되는 것이다.
		  이와 비슷하게 C관점은 출력의 지역 표현으로 맵핑된다.

	- 입출력 수준
		- 저수준 입출력
			: 운영체제가 제공하는 기본적인 입출력 서비스 사용
		- 표준 고수준 입출력
			: C 라이브러리 함수들의 표준 패키지와 stdio.h 헤더 파일 정의들을 사용
		: 모든 운영체제가 동일한 저수준 입출력 모델로 표현될 수 있다는 보장이 없기 때문에, C 표준은 표준 입출력 패키지만을 제공한다.
		  
	- 표준 파일
		: C프로그램은 사용자를 위해 표준 입력, 표준 출력, 표준 에러 출력 이라는 세 개의 파일을 자동으로 연다.
		- 표준 입력은 디폴트로, 키보드와 같은 입력장치
			: getchar(), gets(), scanf()
		- 표준 출력은 디폴트로, 스크린과 같은 출력장치
			: putchar(), puts(), printf()
		- 표준 에러 출력 파일의 목적은 에러 메시지들을 출력할, 논리적으로 구분되는 어떤 장소를 제공하는 것.
			: 예를들어 출력을 스크린 대신에 파일로 보내는 리디렉션을 사용할 때, 표준 에러 출력으로 보내지는 에러 메시지들은 여전히 스크린에 표시된다.
		- 리디렉션
			: 다른 파일들을 표준 입력이나 표준 출력으로 인식되게 만드는 것.

	- 저수준 입출력에 비해 표준 입출력이 가지는 장A점
		1. 다양한 입출력 문제들을 간단하게 처리하는 전문화된 많은 함수들 제공
		2. 입력과 출력에 버퍼를 사용.
			: 정보가 한 번에 한 바이트씩 전달되지 않고, 큰 덩어리(일반적으로 한 번에 512바이트 또는 그 이상)으로 전달된다.

	- exit()
		: 열려 있는 모든 파일들을 닫으면서 프로그램을 종료시킨다. 사용자가 exit()에 제공하는 전달인자는 운영체제에 전달되어, 다른 프로그램들이
		  그것을 사용할 수 있다.
		  일반적으로 프로그램이 정상적으로 종료되는 경우 0을 전달하고, 비정상적으로 종료되는 경우 0이 아닌 값을 전달한다.
		  실패의 여러 원인들을 서로 구별하기 위해 서로 다른 종료값들을 사용할 수 있다.
		  특히, ANSI C 표준은 정상적인 종료를 나타내기 위해 EXIT_SUCCESS를 사용할 것과 비정상적인 종료를 나타내기 위해 매크로 EXIT_FAILURE를
		  사용할 것을 요구한다.
		  이들 매크로는 exit() 프로토타입과 함께 stdlib.h에 들어있다.

	- fopen()
		: FILE *fp = fopen("txt", "r");
		: 첫 번째 전달인자 -> 열려고 하는 파일의 이름 (파일 이름을 가지고 있는 문자열의 주소)
		  두 번째 전달인자 -> 파일을 여는데 사용할 모드를 지정하는 문자열
			"r"		- 읽기
			"w"		- 쓰기: 파일이 이미 존재하면 파일 길이를 0으로 만들고, 없으면 새 파일을 만든다.
			"a"		- 쓰기: 파일이 이미 존재하면 그 파일의 끝에 덧붙이고, 없으면 새 파일을 만든다.
			"r+"	- 갱신
			"w+"	- 갱신: 파일이 이미 존재하면 파일 길이를 0으로 만들고, 없으면 새 파일을 만든다.
			"a+"	- 갱신: 파일이 이미 존재하면 그 파일의 끝에 덧붙이고, 없으면 새 파일을 만든다.
			                (읽기는 전체를 읽을 수 있지만, 쓰기는 끝에 덧붙일 수만 있다.
		: 프로그램이 성공적으로 파일을 열면, fopen()은 파일 포인터를 리턴한다.
		  다른 입출력 함수들은 그 파일 포인터를 그 파일을 나타내는 데 사용한다.
		  파일 포인터는 FILE을 가리키는 포인터형이다. (FILE은 stdio.h에 정의되어있는 유도 데이터형이다.)
		: 포인터 fp는 실제 파일을 가리키지 않는다.
		  대신에 그 파일의 입출력에 사용되는 버퍼 정보를 포함하여, 그 파일에 관한 정보가 들어 있는 데이터 객체를 가리킨다.
		  표준 라이브러리에 있는 입출력 함수들은 버퍼를 사용하기 때문에, 버퍼가 어디에 있는지 알 필요가 있다. 또한 버퍼가 얼마나 채워져 있는지,
		  어느 파일을 사용하는지도 알 필요가 있다. 이 정보들은 필요할 때 함수들이 버퍼를 다시 채우거나 비우는 것을 가능하게 한다.
		  fp가 가리키는 데이터 객체가 그 모든 정보를 가지고 있다.
		: fopen()은 그 파일을 열 수 없을 때 널 포인터를 리턴한다.
		  디스크가 가득 차 있을 때, 파일이 찾는 디렉토리에 없을 때, 이름이 잘못되었을 때, 접근이 제한되어 있을 때, 하드웨어에 문제가 있을 때
		  실패할 수 있다.

	- getc()와 putc()
		: ch = getchar();	-> 표준 입력으로부터 하나의 문자를 얻는다.
		  ch = getc(fp);	-> fp가 나타내는 파일로부터 하나의 문자를 얻는다.
		: putchar(ch);		-> 표준 출력에 하나의 문자를 출력한다.
		  putc(ch, fp);		-> 문자 ch를 fp가 나타내는 파일에 출력한다.

	- 파일의 끝(End-of-File)
		: 파일로부터 데이터를 읽는 프로그램은, 파일의 끝에 도달했을 때 읽기를 멈출 필요가 있다.
		  getc()는 하나의 문자를 읽으려 시도하다가 파일의 끝에 도달했다는 것을 발견하면, EOF라는 특별한 값을 리턴한다.
		  그래서 C 프로그램은 파일의 끝을 읽은 후에 파일의 끝에 도달했다는 것을 알게 된다.
		  (다른 언어들은 읽기 전에 먼저 파일의 끝인지 검사하는 특별한 함수를 사용한다.)

	- fclose()
		: 파일을 성공적으로 닫았으면 0을 리턴하고, 그렇지 않으면 EOF를 리턴한다.

	- 표준 파일을 가리키는 포인터
		: stdio.h 파일은, 세 개의 파일 포인터를 C 프로그램이 자동으로 여는 세 개의 표준 파일에 연결한다.
			1. stdin
			2. stdout
			3. stderr
		  이 포인터들은 모두 FILE을 가리키는 포인터형이다. 그래서 표준 입출력 함수들의 전달인자로 사용할 수 있다.

*/