/*
	- 추상 데이터형(ADT: Abstract Data Type)

		: 하나의 데이터형은 속성들의 집합과 연산들의 집합을 지정한다.
		  ex) int형의 속성은 그것이 정수값을 나타내는 것과, 정수들의 속성을 똑같이 공유한다는 것이다.
		      허용되는 산술 연산은 부호를 바꾸는 것, 사칙연산, 모듈로 이다.
			  어떤 변수를 int형으로 선언하는 것은, 이러한 연산들만이 그 변수에 영향을 끼칠 수 있다고 말하는 것이다.
		: B01_films 프로그램은 정보가 담긴 구조체들의 링크드 집합을 하나 가지고 있고, 정보를 추가하는 코드와 정보를 출력하는 코드를
		  제공한다. 그러나 이 프로그램은 새로운 데이터형을 만들고 있다는 사실을 명확하게 드러내는 방식으로 이 일들을 처리하지 않는다.
	
	- 추상적인 것에서 구체적인 것으로 옮겨 가는 3단계 과정

		1. 데이터형의 속성과, 그 데이터형에 대해 수행할 수 있는 연산들에 대한 추상적인 서술을 제공한다.
		   이 서술이 어떤 특정 구현에 종속적이면 안 된다. 또한 특정 프로그래밍 언어에도 종속적이면 안 된다.
		   그와 같은 형식적이고 추상적은 서술을 추상 데이터형(ADT)이라고 부른다.
		2. ADT를 구현하는 프로그래밍 인터페이스를 개발한다.
		   즉, 데이터를 저장하는 방법과, 원하는 연산들을 수행하는 함수들의 집합을 서술한다.
		   ex) C에서 어떤 구조체의 정의를, 그 구조체를 다루는 함수들의 프로토타입과 함께 제공할 수 있다.
		       이 함수들은, 사용자 정의 데이터형에 대해, C의 내장 연산자들이 C의 기본 데이터형에 대해 수행하는 것과 동일한 역할을 수행한다.
			   새로운 데이터형을 사용하고자 하는 사람은, 자신의 프로그래밍에 이 인터페이스를 사용할 것이다.
		3. 인터페이스를 구현하는 코드를 작성한다.
		   새로운 데이터형을 사용하는 프로그래머는 구현의 세부 사항까지 알 필요는 없다.

	- 추상화 

		: 기본적으로 이 film 프로젝트에 필요한 것은 항목들의 목록이다.
		  각 항목은 영화 타이틀과 평가를 가지고 있다.
		  새로운 항목들을 목록의 끝에 추가할 수 있어야 하고 그 목록의 내용을 출력할 수 있어야 한다.
		  이와 같은 요구 사항을 처리할 추상 데이터형을 리스트라 부르자.
		: 리스트는 여러 항목을 저장할 수 있어야 하고, 이 항목들은 어떤 유형의 순서로 정렬되어 있다.
		  그래서 사용자는 리스트에 있는 첫 번째 항목 또는 두 번째 항목 또는 마지막 항목을 구별할 수 있다.
		: 리스트 데이터형은 항목을 리스트에 추가하는 것과 같은 연산들을 지원해야 한다.
			@ 리스트를 비어 있는 상태로 초기화
			@ 항목 추가
			@ 리스트가 비어 있는지 확인
			@ 리스트가 가득 차 있는지 확인
			@ 리스트에 항목이 몇개 있는지 확인
			@ 항목을 출력하는 것과 같은 동작을 수행하기 위해, 리스트에 들어 있는 각 항목에 접근
			# 항목을 리스트 내의 원하는 위치에 삽입
			# 항목 삭제
			# 항목 교체
			# 특정 항목 찾기
		: 리스트에 대한 추상적인 정의는 그것이 항목들의 시퀀스를 저장할 수 있고, 앞에 열거한 연산들을 적용할 수 있는 어떤 데이터 객체라는 것이다.
		  이 정의는, 그 리스트에 어떤 종류의 항목들이 저장될 수 있는지는 말하지 않는다.
		  이 정의는, 항목들을 저장하는 데 배열, 구조체들의 링크드 집합, 또는 다른 데이터형이 사용되어야 한다고 특별히 지정하지 않는다.
		  예를 들어, 리스트에 몇 개의 원소가 들어 있는지 알아내기 위해 어떤 방법을 사용할 것인지 규정하지 않는다.
		  이 문제들은 모두 구현에 맡겨지는 세부 사항들이다.

	- 인터페이스 만들기

		: 리스트를 위한 인터페이스는 두 부분으로 이루어 진다.
			1. 데이터를 나타내는 방법을 서술 한다
			2. ADT 연산을 구현하는 함수들을 서술한다.
		: 인터페이스 설계는 ADT 서술과 가능하면 일치해야 한다.
		  그러므로 int나 struct film와 같은 구체적인 데이터형 대신에 좀더 일반적인 Item형으로 표현되어야 한다.
		  한 가지 방법은, C의 typedef 기능을 사용하여 Item을 필요한 데이터형으로 정의하는 것이다.
				struct film
				{
					char title[45];
					int rating;
				};
				typedef struct film Item;
		  그러고 나면 그 정의 나머지에 Item형을 사용할 수 있다. 나중에 다른 데이터형의 리스트를 원한다면, Item형만 다시 정의하고, 
		  인터페이스 정의의 나머지는 그대로 유지할 수 있다.
		: Item형을 정의했으므로, 이제 그 데이터형의 항목들을 어떻게 지정할 것인지 결정해야 한다.
				typedef struct node
				{
					Item item;
					struct node* next;
				} Node;
				typedef Node* List;
		  typedef를 사용하여 Node를 strut node 구조체의 데이터형 이름으로 만들었다.
		  마지막으로, 링크드 리스트를 다루기 위해, 링크드 리스트의 시작을 가리키는 포인터가 필요하다.
		  그래서 typedef를 사용하여 List를 Node형을 가리키는 포인터로 만들었다.
				List movies;
		  따라서 위와 같은 선언은 movies를 링크드 리스트를 참조하는 적합한 포인터로 선언한다.
		  여기서 중요한 것은, 위와 같은 선언이 노드를 가리키는 포인터 또는 구조체를 선언하는 것이 아니라,
		  리스트를 선언하는 것으로 생각해야 한다는 점이다.
		  movies의 정확한 데이터 표현은, 인터페이스 수준에서는 드러나지 않아야 하는 구현의 세부 사항이다.
		  ex) 프로그램을 시작할 때 리스트의 머리 포인터를 NULL로 초기화해야 한다.
		      그것은 다음과 같은 초기화를 요구할 것이다.
					movies->next = NULL;
					movies->size = 0;
			  List형을 사용하는 사람은 이와 같은 세부 사항에 대해서 고민하면 안 된다.
			  그 대신에 다음과 같은 라인을 사용하여 초기화를 처리할 수 있어야 한다.
					InitailizeList(&movies):
			  사용자는 리스트를 초기화하기 위해 위 함수를 사용해야 한다는 사실만 알면 된다.
			  List 변수의 정확한 데이터 구현에 대해서는 알 필요가 없다.
			  이것은, 데이터 표현의 세부 사항을 고수준 프로그래밍으로부터 감추는 기술인, 데이터 은폐의 한 예이다.
		: C에서 데이터형과 함수 정보를 패키지로 묶는 방법은, 데이터형 정의와(주석 포함) 함수 프로토타입을 하나의 헤더 파일에 넣는 것이다.
		  사용자가 그 데이터형을 사용하는 데 필요한 모든 정보를 이 헤더 파일이 제공해야 한다.
		: 이 파일은 특정 구조체를 Item형으로 정의한다.
		  Item을 사용하여 Node를 정의한다.
		  Node를 사용하여 List를 정의한다.
		: 리스트를 연산 대상으로 하는 함수들은 Item과 List형을 전달인자로 사용한다.
		  함수가 전달인자를 변경할 필요가 있다면, 그 데이터형을 직접 사용하는 대신에, 그 데이터형을 가리키는 포인터를 사용한다.
		 
*/

#ifndef LIST_H_
#define LIST_H_
#include <stdbool.h>

/* 프로그램에 종속적인 선언 */
#define TSIZE 45
struct film
{
	char title[TSIZE];
	int rating;
};

typedef struct film Item;

/* 포괄적인 데이터형 정의 */
typedef struct node
{
	Item item;
	struct node* next;
} Node;

typedef Node* List;

/* 함수 프로토타입 */

/*
	연산:			리스트를 초기화한다.
	사전 조건:		plist는 리스트를 가리킨다.
	사후 조건:		리스트가 빈 상태로 초기화된다.
*/
void InitializeList(List* plist);

/*
	연산:			리스트가 비어 있는지 확인한다.
	사전 조건:		plist는 초기화된 리스트를 가리킨다.
	사후 조건:		리스트가 비어 있으면 true를 리턴한다.
					그렇지 않으면 false를 리턴한다.
*/
bool ListIsEmpty(const List* plist);

/*
	연산:			리스트가 가득 차 있는지 확인한다.
	사전 조건:		plist는 초기화된 리스트를 가리킨다.
	사후 조건:		리스트가 비어 있으면 true를 리턴한다.
					그렇지 않으면 false를 리턴한다.
*/
bool ListIsFull(const List* plist);

/*
	연산:			리스트에 얼마나 많은 항목들이 있는지 확인한다.
	사전 조건:		plist는 초기화된 리스트를 가리킨다.
	사후 조건:		리스트에 있는 항목들의 개수를 리턴한다.
*/
unsigned int ListItemCount(const List* plist);

/*
	연산:			항목을 리스트의 끝에 추가한다.
	사전 조건:		item은 리스트에 추가할 항목이다.
					plist는 초기화된 리스트를 가리킨다.
	사후 조건:		가능할 경우에, 항목을 리스트의 끝에 추가하고 true를 리턴한다.
					그렇지 않으면 false를 리턴한다.
*/
bool AddItem(Item item, List* plist);

/*
	연산:			리스트에 있는 각 항목에 함수를 적용한다.
	사전 조건:		plist는 초기화된 리스트를 가리킨다.
					pfun은 Item을 전달인자로 사용하고 리턴값이 없는 함수를 가리킨다.
	사후 조건:		pfun이 가리키는 함수는 리스트에 있는 각 항목마다 한 번씩 수행된다.
*/
void Traverse(const List* plist, void (*pfun)(Item item));

/*
	연산:			가능할 경우에, 할당된 메모리를 해제한다.
	사전 조건:		plist는 초기화된 리스트를 가리킨다.
	사후 조건:		리스트에 할당된 모든 메모리가 해제되고 리스트가 비어 있는 상태로 설정된다.
*/
void EmptyTheList(List* plist);







#endif