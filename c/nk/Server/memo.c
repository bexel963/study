/*
	- 운영체제 소켓
		: 물리적으로 연결된 네트워크상에서의 데이터 송수신에 사용할 수 있는 소프트웨어적인 장치.
		: 네트워크 망에 연결에 사용되는 도구.
*/

// ---------------------------------------------------------------<리눅스 기반>---------------------------------------------------------------

/*
	- server
		1. 소켓 생성. (=서버 소켓, 리스닝 소켓)
			: int socket(int domain, int type, int protocol)

		2. 소켓을 생성한 후 IP와 포트번호라는, 소켓의 주소정보에 해당하는 것을 할당한다.
			: int bind(int sockfd, struct sockaddr *myaddr, socklen_t addrlen)

		3. 생성한 소켓에 연결 요청이 가능한 상태로 만든다.
			: int listen(int sockfd, int backlog)

		4. 요청이 오면 그 요청을 수락한다.
			: int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)

	- client. (=클라이언트 소켓)
		1. 소켓 생성.
			: int socket(int domain, int type, int protocol)

		2. 서버로의 연결 요청.
			: int connect(int sockfd, struct sockaddr *serv_addr, socklen_t addrlen)
*/
/*
	- 파일 조작하기
		: 리눅스에서의 소켓조작은 파일조작과 동일하게 간주된다.
		  따라서 파일 입출력 함수를 소켓 입출력에(네트워크상에서의 데이터 송수신에) 사용할 수 있다.
		: 윈도우는 리눅스와 달리 파일과 소켓을 구분하고 있다. 때문에 별도의 데이터 송수신 함수를 참조해야 한다.

	- 저 수준("표준에 상관없이 OS가 독립적으로 제공하는~") 파일 입출력, 파일 디스크립터(파일 핸들)
		: 저 수준 함수란, ANSI표준에서 정의한 함수가 아니라 해당 OS에서 제공하는 함수이다.
		: 파일 디스크립터란, 시스템으로부터 할당 받은 파일 또는 소켓에 부여된 정수를 의미한다.
		  OS가 만든 파일 또는 소켓의 지칭을 편히 하기 위해서 부여한 숫자이다.
		: 일반적으로 파일과 소켓은 생성의 과정을 거쳐야 파일 디스크립터가 할당된다.
		  반면, 0, 1, 2번은 별도의 생성과정을 거치지 않아도 프로그램이 실행되면 자동으로 할당되는 파일 디스크립터들이다.
				0 -> 표준입력(Standard Input)
				1 -> 표준출력(Standard Output)
				2 -> 표준에러(Standard Error)

	- 시스템(OS)에서 정의하는 자료형
		: 프로그래머에 의해 정의되는 자료형 이름과의 구분을 위해서, 시스템(OS)에서 정의하는 자료형의 이름에는 _t 가 붙는다.
		  (ssize_t, size_t 등...)

	- 파일
		1.열기 - int open(const char *path, int flag)
				: path -> 파일 이름을 나타내는 문자열의 주소 값 전달.
				  flag -> 파일의 오픈 모드 정보 전달.
		2.닫기 - int close(int fd)
		3.쓰기 - ssize_t write(int fd, const void *buf, size_t nbytes)
		4.읽기 - ssize_t read(int fd, void *buf, size_t nbytes)
*/

// ---------------------------------------------------------------<윈도우 기반>---------------------------------------------------------------

/*
	- 윈속(윈도우 소켓)을 기반으로 프로그래밍을 하기 위해서는 기본적으로 두 가지를 진행해야 한다.
			1. 헤더파일 winsock2.h를 포함시킨다.
			2. ws2_32.lib 라이브러리를 링크 시킨다.

	- 윈속 프로그래밍을 할 때는 반드시 WSAStartup 함수를 호출해서, 프로그램에서 요구하는 윈도우 소켓의 버전을 알리고, 해당 버전을 지원하는
	  라이브러리의 초기화 작업을 진행해야 한다.
			: int WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData)
				: 사용할 소켓의 버전정보를 WORD형으로 구성해서, 위 함수의 첫 번째 매개변수로 전달해야 한다.
				  (WORD는 typedef 선언을 통해서 unsigned short로 정의되어있다.)
				  (만약, 사용할 소켓의 버전이 1.2라면, 1이 주 버전이고 2가 부 버전이므로 0x0201을 인자로 전달해야 한다.)
				: 그런데 바이트 단위로 쪼개서 버전정보를 설정하는 것이 조금 번거롭기 때문에  매크로 함수인 MAKEWORD가 제공되고 있다.
				  이 함수를 사용하면 간단히 WORD형 버전정보를 구성할 수 있다.
						MAKEWORD(1, 2);	// 주 버전 1, 부 버전 2, 0x0201 반환
						MAKEWORD(2, 2)	// 부 버전 2, 부 버전 2, 0x0202 반환
				: 두 번째 매개변수 lpWSAData에는 WSADATA 구조체 변수의 주소값을 인자로 전달해야 한다.
				  (LPWSADATA는 WSADATA의 포인터 형이다.)
				  그러면, 함수호출이 완료되고 난 다음에 해당 변수에는 초기화된 라이브러리의 정보가 채워진다.
			: int WSACleanup(void);
				: 위 함수를 호출하면, 할당된 윈속 라이브러리는 윈도우 운영체제에 반환이 되면서, 윈속관련 함수의 호출이 불가능해진다.

	- server
		1. 소켓 생성
			: SOCKET socket(int af, int type, int protocol)					// 성공 시 소켓 핸들, 실패 시 INVALID_SOCKET 반환

		2. 소켓에 IP주소와 PORT번호의 할당
			: int bind(SOCKET s, const struct *name, int namelen)			// 성공 시 소켓 핸들, 실패 시 INVALID_SOCKET 반환

		3. 소켓이 클라이언트 프로그램의 연결요청을 받아들일 수 있는 상태가 되게 한다.
			: int listen(SOCKET s, int backlog)								// 성공 시 0, 실패 시 SOCKET_ERROR 반환

		4. 클라이언트 프로그램에서의 연결요청을 수락한다.
			: SOCKET accept(SOCKET s, struct sockaddr *addr, int *addrlen)	// 성공 시 소켓 핸들, 실패 시 INVALID_SOCKET 반환

	- client
		1. 소켓을 기반으로 서버에 연결요청을 한다.
			: int connect(SOCKET s, const struct sockaddr *name, int namelen)	// 성공 시 0, 실패 시 SOCKET_ERROR 반환

		2. 소켓을 닫는다.
			: int closesocket(SOCKET s)											// 성공 시 0, 실패 시 SOCKET_ERROR 반환
*/

/*
	- 리눅스는 내부적으로 소켓도 파일로 취급하기 때문에, 파일을 생성하건 소켓을 생성하건 파일 디스크립터가 반환된다.
	  윈도우에서는 시스템 함수의 호출을 통해서 파일을 생성할 때 '핸들'이라는 것을 반환한다.
	  그런데 윈도우는 리눅스와 달리 파일 핸들과 소켓 핸들을 구분하고 있다.
	- SOCKET이라고 선언되어 있는 매개변수 및 반환형은 정수로 표현되는 소켓의 핸들 값 저장을 위해서 tpyedef 선언으로 정의된 새로운 자료형의 이름이다.
*/

/*
	- 윈도우 기반 입출력 함수
		: 리눅스는 소켓도 파일로 간주하기 때문에, 파일 입출력 함수인 read와 write를 이용해서 데이터를 송수신할 수 있다.
		  그러나 윈도우는 파일 입출력 함수와 소켓 입출력 함수가 엄연히 구분된다.
			1.입력
				: int send(SOCKET s, const char* buf, int len, int flags)
					: s		-> 데이터를 받을 소켓의 핸들 값
					: len	-> 전송할 바이트 수
			2.출력
				: int recv(SOCKET s, const char* buf, int len, int flags)
					: s		-> 데이터를 보내는 소켓의 핸들 값
					: len	-> 수신할 수 있는 최대 바이트 수
					: flags -> 데이터 수신 시 적용할 옵션 정보
*/

/*
	- SOCKET socket(int af, int type, int protocol)

	- 반환형SOCKET
		: 정수로 표현되는 소켓의 핸들 값을 저장하기 위해 정의된 자료형의 이름.
		  반환되는 값이 정수이다 보니, int형 변수를 하나 선언해서 값을 저장해도 되지만 앞으로의 확정성을 고려해서 SOCKET라는 이름의 자료형이
		  정의 되었으니 이를 핸들 값 저장에 필요한 자료형으로 인식하면 된다.

	- 프로토콜
		: 컴퓨터 상호간의 대화에 필요한 통신 규약, 서로 데이터를 주고 받기 위해서 정의해 놓은 약속

	- af
		: 프로토콜 체계(Protocol Family)
		: socket 함수의 첫 번째 인자로, 생성되는 소켓이 사용할 프로토콜의 부류정보를 전달해야 하는데, 이러한 부류정보를 '프로토콜 체계'라고 한다.
			PF_INET		-> IPv4 인터넷 프로토콜 체계
			PF_INET6	-> IPv6 인터넷 프로토콜 체계
			PF_LOCAL	-> 로컬 통신을 위한 UNIX 프로토콜 체계
			PF_PACKET	-> Low Level 소켓을 위한 프로토콜 체계
			PF_IPX		-> IPX 노벨 프로토콜 체계
		: 실제 소켓이 사용할 최종 프로토콜 정보는 socket 함수의 세 번째 인자를 통해서 전달하게 되어있다. 단, 첫 번째 인자를 통해서 지정한 프로토콜
		  체계의 범위 내에서 세 번째 인자가 결정되어야 한다.

	- type
		: 소켓의 타입(소켓의 데이터 전송방식)
		: socket 함수의 첫 번째 인자로 전달되는 하나의 특정 프로토콜 체계에도 둘 이상의 데이터 전송방식이 존재 하는데 이것을 두 번째 인자에서 확정짓는다.
			SOCK_STREAM(연결지향형 소켓)
				-> 하나의 라인을 통해 데이터를 주고 받는다.
				   중간에 데이터가 소멸되지 않고 목적지로 전송된다.
				   전송 순서대로 데이터가 수신된다.
				   전송되는 데이터의 경계가 존재하지 않는다.
				   ex) 데이터를 전송하는 컴퓨터가 세 번의 send()를 호출해서 총 100byte를 전송 하였다.
					   그런데 데이터를 수신하는 컴퓨터는 한 번의 recv()를 호출해서 100byte를 전부 수신 하였다.
				   데이터를 송수신하는 소켓은 내부적으로 버퍼를 지니고 있다. 그리고 소켓을 통해 전송되는 데이터는 일단 이 배열에 저장된다.
				   때문에 데이터가 수신되었다고 해서 바로 recv()를 호출해야 하는 것은 아니다.
				   이 배열의 용량을 초과하지 않는 한, 데이터가 채워진 후에 한 번의 recv()를 호출해서 데이터를 전부 읽어 들일수도 있고, 반대로
				   한번의 send()호출로 전송된 데이터 전부를 여러 번의 recv()를 호출해서 읽어 들일수도 있다.
				   즉, send()호출 횟수와 recv()호출 횟수는 연결지향형 소켓의 경우 큰 의미를 갖지 못한다.
				   때문에 연결지향형 소켓은 데이터의 경계가 존재하지 않는다고 하는 것이다.
				   recv()로 읽혀지는 데이터의 양보다 많은 양의 데이터가 수신되면 데이터를 전송하는 영역의 소켓이 더 이상 데이터를 전송하지 않기 때문에
				   전송되는 데이터가 손실되는 일은 발생하지 않는다.
			SOCK_DGRAM(비 연결지향형 소켓)
				-> 전송된 순서에 상관없이 가장 빠른 전송을 지향한다.
				   전송된 데이터는 손실의 우려가 있고, 파손의 우려가 있다.
				   전송되는 데이터의 경계가 존재한다. (send()호출 횟수와 recv()호출 횟수가 같다.)
				   한번에 전송할 수 있는 데이터의 크기가 제한된다.

	- protocol
		: 프로토콜의 최종 선택(최종적으로 소켓이 사용하게 될 프로토콜 정보를 전달하는 목적으로 존재한다.)
		  일반적인 경우 첫 번째, 두 번째 인자 정보를 통해서 충분히 원하는 유혀으이 소켓을 생성할 수 있고 이러한 경우에는 세 번째 인자를 0으로 놔도 된다.
		  그러나 '하나의 프로토콜 체계 안에 데이터의 전송방식이 동일한 프로토콜이 둘 이상 존재하는 경우' 세 번째 인자를 통해서 원하는 프로토콜 정보를
		  조금 더 구체화해야 한다.

	ex1) int tcp_socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
		: IPv4 인터넷 프로토콜 체계에서 동작하는 연결지향형 데이터 전송 소켓

	ex2) int udp_socket = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
		: IPv4 인터넷 프로토콜 체계에서 동작하는 비 연결지향형 데이터 전송 소켓

*/

// ---------------------------------------------------------------<IP주소 & 포트번호>---------------------------------------------------------------

/*
	▶ IP는 인터넷상에서 데이터를 송수신할 목적으로 컴퓨터에게 부여하는 값을 의미한다.
	   Port번호는 컴퓨터에게 부여하는 값이 아닌, 프로그램상에서 생성되는 소켓을 구분하기 위해 소켓에 부여되는 번호이다.

	▶ 인터넷 주소
		
		- 인터넷에 컴퓨터를 연결해서 데이터를 주고받기 위해서는 IP주소를 부여 받아야 한다.
			: IPv4 (Internet Protocol version 4)	-> 4byte 주소체계
			: IPv6 (Internet Protocol version 6)	-> 16byte 주소체계
		
		- IPv4는 네트워크 주소와 호스트(컴퓨터를 의미함) 주소로 나뉘며, 주소의 형태에 따라서 A, B, C, D, E클래스로 분류가 된다.

			: 클래스 A -> 네트워크ID(1BYTE)	/	호스트ID(3BYTE)
			: 클래스 B -> 네트워크ID(2BYTE)	/	호스트ID(2BYTE)
			: 클래스 C -> 네트워크ID(3BYTE)	/	호스트ID(1BYTE)
			: 클래스 D -> 네트워크ID(4BYTE)	

			: 네트워크 주소(네트워크ID)란 네트워크의 구분을 위한 IP주소의 일부를 말한다.
			  데이터를 다른 컴퓨터로 보내려면 처음부터 4바이트 IP주소 전부를 참조해서 보내는게 아니라 4바이트 IP주소 중 네트워크 주소(네트워크ID)만을 참조해서 일단
			  그 컴퓨터와 연결되어 있는 로컬 네트워크로 전송한다.
			  네트워크로 데이터가 전송된다는 것은 네트워크를 구성하는 라우터 또는 스위치로 데이터가 전송됨을 뜻한다.
			  그 후 데이터를 전송 받은 라우터는 데이터에 적혀있는 호스트 주소(호스트ID)를 참조하여 호스트에 데이터를 전송해준다.

		- 네트워크를 구성하려면 외부로부터 수신된 데이터를 호스트에 전달하고, 호스트가 전달하는 데이터를 외부로 송신해주는 물리적 장치가 필요하다.
		  이를 가리켜 라우터 또는 스위치라고 하는데, 이것도 그냥 컴퓨터에 지나지 않는다. 다만 특수한 목적을 가지고 설계 및 운영되는 컴퓨터이기 때문에 라우터 또는 스위치
		  라는 별도의 이름을 붙여준 것이다.

	▶ 클래스 별 네트워크 주소와 호스트 주소의 경계

		- IP주소의 첫 번째 바이트만 딱 보면 네트워크 주소가 몇 바이트인지 판단이 가능하다. 클래스 별 IP주소의 경계를 나눠 놓았기 때문이다.
	
			: 클래스 A의 첫 번째 바이트 범위	->   0 ~ 127	=> 클래스A의 첫 번째 비트는 항상   0으로 시작
			: 클래스 B의 첫 번째 바이트 범위	-> 128 ~ 191	=> 클래스B의 첫 번째 비트는 항상 128으로 시작
			: 클래스 C의 첫 번째 바이트 범위	-> 192 ~ 223	=> 클래스C의 첫 번째 비트는 항상 192으로 시작

			: 이러한 기준이 정해져 있기 때문에 소켓을 통해서 데이터를 송수신할 때, 우리가 별도로 신경쓰지 않아도 네트워크로 데이터가 이동하고 이어서 최종 목적지인
			  호스트로 데이터가 전송되는 것이다.

	▶ 소켓의 구분에 활용되는 port번호

		- 둘 이상의 컴퓨터로부터 데이터를 전송 받으려면 둘 이상의 소켓이 생성되어야 한다. 그렇다면 이들 소켓은 어떻게 구분해야 하는가...
		 
			: 컴퓨터에는 NIC(네트워크 인터페이스 카드)이라 불리는 데이터 송수신 장치가 하나씩 달려있다. IP는 데이터를 NIC을 통해 컴퓨터 내부로 전송하는데 사용된다.
			  그러나 컴퓨터 내부로 전송된 데이터를 소켓에 적절히 분배하는 작업은 OS가 담당한다. 이 때 운영체제는 PORT 번호를 활용한다.
			  즉 NIC을 통해서 수신된 데이터 안에는 PORT번호가 새겨져 있다. OS는 바로 이 정보를 참조해서 일치하는 PORT번호의 소켓에 데이터를 전달하는 것이다.
			: PORT번호는 하나의 OS내에서 소켓을 구분하는 목적으로 사용되기 때문에 하나의 운영체제 내에서 동일한 PORT번호를 둘 이상의 소켓에 할당할 수 없다.
			  그리고 PORT번호는 16비트로 표현된다. 때문에 할당할 수 있는 PORT번호의 범위는 0~65535 이다.
			  그러나 0~1023번지는 '잘 알려진 PORT' 라고 해서, 특정 프로그램에 할당하기로 예약되어있기 때문에 이 범위의 값을 제외한 다른 값을 할당해야 한다.
			: PORT번호는 중복이 불가능 하지만, TCP소켓과 UDP소켓은 PORT번호를 공유하지 않기 때문에 중복되어도 상관 없다.

			=> 데이터 전송의 목직지 주소에는 IP주소뿐만 아니라 PORT번호도 포함이 된다. 그래야 최종 목적지에 해당하는 응용프로그램의 소켓까지 데이터를 전달 할 수 있다.

	▶ IPv4 기반의 주소표현을 위한 구조체
		
		- uint16_t, in_addr_t 와 같은 자료형의 근거는 POSIX(Portable Operation System Interface)에서 찾을 수 있다.
		  POSIX란 유닉스 계열의 OS에서 적용하기 위한 표준을 의미한다.

		- POSIX에서 정의하고 있는 자료형
			
			int8_t			signed 8-bit int
			uint8_t			unsigned 8-bit int(unsigned char)
			int16_t			signed 16-bit int
			uint16_t		unsigned 16-bit int(unsigned short)
			int32_t			signed 32-bit int
			uint32_t		unsigned 32-bit int(unsigned long)

			sa_family_t		주소체계(address family)
			SOCKlen_t		길이정보(length of struct)

			in_addr_t		IP주소정보, uint32_t로 정의되어 있음
			in_port_t		PORT번호정보, uint16_t로 정의되어 있음

			: 자료형을 별도로 정의해 놓은 이유는 확장성을 고려한 결과이다. 즉, int32_t라는 자료형을 사용한다면, 이는 어떠한 경우에도
			  4바이트 자료형임을 보장받을 수 있다. 혹 이후에 자료형 int가 64비트로 표현되는 날이 오더라도 말이다.

			struct in_addr
			{
				in_addr_t		s_addr;			// 32비트 IPv4 인터넷 주소
			}

			struct sockaddr_in
			{
				sa_family_t		sin_family;		// 주소체계
				uint16_t		sin_port;		// 16비트 TCP/UDP PORT번호
				struct in_addr	sin_addr;		// 32비트 IP주소
				char			sin_zero[8];	// 사용되지 않음
			};		

	▶ 구조체 sockaddr_in의 멤버에 대한 분석

		- sin_family(주소체계)

			: AF_INET	-> IPv4 인터넷 프로토콜에 적용되는 주소체계
			  AF_INET6	-> IPv6 인터넷 프로토콜에 적용되는 주소체계
			  AF_LOCAL	-> 로컬 통신을 위한 유닉스 프로토콜의 주소체계

		- sin_port
			: 16비트 port번호를 저장한다. 단, '네트워크 바이트 순서'로 저장해야 한다.

		- sin_addr
			: 32비트 ip주소정보를 저장한다. 단, '네트워크 바이트 순서'로 저장해야 한다.
			  구조체 in_addr의 유일한 멤버가 uint32_t로 선언되어 있으니, 간단히 32비트 정수자료형으로 인식해도 된다.

		- sin_zero
			: 단순히 구조체 sockaddr_in의 크기를 구조체 sockaddr와 일치시키기 위해 삽입된 멤버이다.
			  반드시 0으로 채워져야 한다. 만약 0으로 채우지 않으면 원하는 결과를 얻지 못한다.

		- sockaddr_in 구조체 변수의 주소 값은 bind()의 인자로 전달된다.

				struct sockaddr_in serv_addr;
				...
				bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr))	// serv_sock에 serv_addr을 할당한다.
				...

			: bind()는 sockaddr 구조체 변수의 주소 값을 요구한다. 그러나 sockaddr는 정보를 담기에 불편하게 정의되어 있다.
				그래서 등장한 것이 구조체 sockaddr_in 이다.
				결국 인자전달을 위한 형변환을 통해서 sockaddr 구조체 변수에 bind()가 요구하는 바대로 데이터를 채워 넣는 효과를 볼 수 있다.

				struct sockaddr
				{
					sa_family_t		sin_family;		// 주소체계
					char			sa_data[14];	// 주소정보(IP+PORT) - 남은 부분은 0으로 채운다.
				}
				
			: sockaddr_in은 IPv4의 주소정보를 담기 위해 정의된 구조체이다. 그럼에도 주소체계 정보를 구조체 멤버 sin_family에 별도로 저장하는
				이유는 sockaddr과 관련이 있다.
				구조체 sockaddr은 IPv4의 주소정보만을 담기 위해 정의된 구조체가 아니다. 주소정보를 담는 배열 sa_data의 크기가 14바이트인 것을
				보면 알 수 있다. 따라서 구조체 sockaddr에서는 주소체계 정보를 구조체 멤버 sin_family에 저장할 것을 요구하고 있다.
				때문에 sockaddr과 동일한 바이트 열을 편히 구성하기 위해 정의된 구조체 sockaddr_in에도 주소체계 정보를 담기 위한 멤버가 존재하는 것이다.

	▶ 바이트 순서, 네트워크 바이트 순서

		- CPU가 데이터를 메모리에 저장하는 방식(데이터를 해석하는 방식)은 두 가지로 나뉜다.
			
			: 빅 엔디안		-> 상위 바이트의 값을 작은 번지수에 저장하는 방식
			: 리틀 엔디안	-> 상위 바이트의 값을 큰 번지수에 저장하는 방식 (거꾸로)

		- CPU의 데이터 저장방식을 의미하는 '호스트 바이트 순서'는 CPU에 따라서 차이가 난다. 참고로 인텔계열 CPU는 리틀 엔디안 방식으로 데이터를 저장한다.
		  호스트 바이트 순서가 다른 두 CPU가 데이터를 주고받을 때 문제가 발생한다.
		  때문에 네트워크를 통해서 데이터를 전송할 때에는 통일된 기준으로 데이터를 전송하기로 약속하였으며, 이 약속을 가리켜 '네트워크 바이트 순서'라 한다.
		  네트워크 바이트 순서는 빅 엔디안 방식으로 통일하는 것이다.
		  즉, 네트워크 상으로 데이터를 전송할 때에는 데이터의 배열을 빅 엔디안 기준으로 변경해서 송수신하기로 약속한 것이다. 때문에 모든 컴퓨터는 수신된
		  데이터가 네트워크 바이트 순서로 정렬되어 있음을 인식해야 하며, 리틀 엔디안 시스템에서는 데이터를 전송하기에 앞서 빅 엔디안의 정렬방식으로 데이터를
		  재정렬 해야한다.

	▶ 바이트 순서의 변환

		- 구조체 sockaddr_in에 값을 채우기 앞서 네트워크 바이트 순서로 변환해서 저장해야 한다.

			: unsigned short htons(unsigned short);		// short형 데이터를 호스트 바이트 순서에서 네트워크 바이트 순서로 변환
			  unsigned short ntohs(unsigned short);		// short형 데이터를 네트워크 바이트 순서에서 호스트 바이트 순서로 변환
			  unsigned long htonl(unsigned long);		
			  unsigned long ntohl(unsigned long);

			: htons에서의 h는 호스트 바이트 순서를 의미한다.
			  htons에서의 n은 네트워크 바이트 순서를 의미한다.

			: 일반적으로 s가 붙는 함수는 s가 2byte short를 의미하므로 PORT번호의 변환에 사용되고,
			  l이 붙는 함수는 l이 4byte long를 의미하므로 IP주소의 변환에 사용된다. 

		- 데이터 송수신 과정에서 네트워크 바이트 순서로 자동으로 변환이 된다.
		  그래서 sockaddr_in 구조체 변수에 데이터를 채울 때 이외에는 바이트 순서를 신경 쓰지 않아도 된다.

	▶ 문자열 정보를 네트워크 바이트 순서의 정수로 변환하기

		- sockaddr_in 안에서 주소정보를 저장하기 위해 선언된 멤버는 32비트 정수형으로 정의되어 있다. 따라서 IP주소 정보의 할당을 위해서 32비트 정수형태로
		  IP주소를 표현할 수 있어야 한다.
		  그러나 우리는 IP주소를 표현할 때 "211.214.107.99"와 같이 점이 찍힌 십진수 표현방식에 더 익숙하다.
		  다행히 문자열로 표현된 IP주소를 32비트 정수형으로 변환해 주는 함수가 있다. 뿐만 아니라 이 함수는 반환과정에서 네트워크 바이트 순서로의 변환도 동시에 해준다.

			: in_addr_t inet_addr(const char* string);

			: inet_addr 함수는 32비트 정수형태로 IP주소를 변환할 뿐만 아니라, 유효하지 못한 IP주소에 대한 오류검출 능력도 갖고 있다.

		- inet_addr 함수와 반대 기능을 하는 함수도 있다.
			
			: char* inet_ntoa(struct in_addr adr);

			: 인자로 전달된 정수형태의 IP정보를 참조하여 문자열 형태의 IP정보로 변환해서, 변환된 문자열의 주소 값을 반환한다.
			  반환형이 char형 포인터이다.
			  함수 내부적으로 메모리공간을 할당해서 변환된 문자열 정보를 저장한다. 따라서 이 함수를 호출한 후에는 가급적 반환된 문자열 정보를 다른 메모리 공간에
			  복사해 두는 것이 좋다. 다시 한번 inet_ntoa 함수가 호출되면, 전에 저장된 문자열 정보가 지워질 수 있기 때문이다.

	▶ 인터넷 주소의 초기화
		
		- struct sockaddr_in addr;
		  char *serv_ip = "211.217.168.13";
		  char *serv_port = "9190";	
		  memset(&addr, 0, sizeof(addr));				// 구조체 변수의 모든 멤버를 0으로 초기화 
		  addr.sin_family = AF_INET;					// 주소체계 지정
		  addr.sin_addr.s_addr = inet_addr(serv_ip);	// 문자열 기반의 IP주소 초기화
		  addr.sin_port = htons(atoi(serv_port));		// 문자열 기반의 PORT번호 초기화

			: addr 멤버를 전부 0으로 초기화 하는 이유는, 0으로 초기화해야 하는 sockaddr_in 구조체 멤버 sin_zero를 0으로 초기화 하기 위함이다.
			  atoi함수는 문자열로 표현되어 있는 값을 정수로 변환해서 반환한다.

		- 서버소켓의 외침				-> IP 211.217.168.13, PORT 9190 으로 들어오는 데이터는 내게로 다 보내라!!
		- 클라이언트 소켓의 외침		-> IP 211.217.168.13, PORT 9190 으로 연결을 해라!! 

			: 서버 프로그램의 외침은 bind함수를 통해 이뤄지고, 클라이언트 프로그램의 외침은 connect함수를 통해서 이뤄진다.
			  
			: 서버 프로그램에서는 sockaddr_in 변수를 하나 선언해서, 이를 서버 소켓이 동작하는 컴퓨터의 IP와 소켓에 부여할 PORT번호로 초기화한 다음에 bind함수를 호출한다.
			  클라이언트 프로그램에서는 sockaddr_in 변수를 하나 선언해서, 이를 연결할 서버 소켓의 IP와 PORT번호로 초기화한 다음에 connect함수를 호출한다.

	▶ INADDR_ANY

		- 소켓의 IP주소를 INADDR_ANY로 초기화할 경우 소켓이 동작하는 컴퓨터의 IP주소가 자동으로 할당되기 때문에 IP주소를 직접 입력하는 수고를 덜 수 있다.
		  뿐만 아니라, 컴퓨터 내에 두 개 이상의 IP를 할당 받아서 사용하는 경우(이를 가리켜 Multi-homed 컴퓨터라 하며, 일반적으로 라우터가 이에 해당한다.), 할당 받은 IP중
		  어떤 주소를 통해서 데이터가 들어오더라도 PORT번호만 일치하면 수신할 수 있게 된다. 따라서 서버 프로그램의 구현에 많이 선호되는 방법이다.

		- 서버 소켓은, 생성시 자신이 속한 컴퓨터의 IP주소로 초기화가 이뤄져야 한다. 그럼에도 IP주소의 초기화를 요구하는 것에 의문을 가질 수 있다.
		  하나의 컴퓨터에 둘 이상의 IP주소가 할당될 수 있다는 사실을 통해 이 부분을 이해할 수 있다.
		  IP주소는 컴퓨터에 장착되어 있는 NIC(랜카드)의 개수만큼 부여가 가능하다.
		  그리고 이러한 경우에는 서버 소켓이라 할지라도 어느 IP주소로(어느 NIC으로) 들어오는 데이터를 수신할지 결정해야 한다.
		  때문에  서버 소켓의 초기화 과정에서 IP주소 정보를 요구하는 것이다. 반면 NIC이 하나뿐인 컴퓨터라면 주저 없이 INADDR_ANY를 이용해서 초기화하는 것이 편리하다.

	▶ 127.0.0.1을 루프백 주소라 하며 이는 컴퓨터 자신의 IP주소를 의미한다.
*/