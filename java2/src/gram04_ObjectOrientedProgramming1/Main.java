package gram04_ObjectOrientedProgramming1;

/*
    - 객체지향언어
        : '실제 세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용이다.
          실제 사물의 속성과 기능을 분석한 다음, 데이터(변수)와 함수로 정의함으로써 실제 세계를 컴퓨터 속에 옮겨 놓은 것과 같은 가상 세계를 구현하고,
          이 가상세계에서 모의실험을 함으로써 많은 시간과 비용을 절약할 수 있다.
          프로그램의 규모가 점점 커지고 사용자들의 요구가 빠르게 변화해가는 상황을 절차적 언어로는 극복하기 어렵다는 한계를 느끼고 객체지향언어를 이용한 개발방법론이
          대안으로 떠오르게 되면서 조금씩 입지를 넓혀가고 있다.
          기존의 프로그래밍 언어에 몇 가지 새로운 규칙을 추가한 보다 발전된 형태의 것이며, 이러한 규칙들을 이용해서 코드간에 서로 '관계'를 맺어 줌으로써 보다 유기적으로
          프로그램을 구성하는 것이 가능해졌다.
          객체지향이론에서는 사물과 같은 유형적인 것 뿐만 아니라, 개념이나 논리와 같은 무형적인 것들도 객체로 간주한다.
          프로그래밍에서의 객체는 클래스에 정의된 내용대로 메모리에 생성된 것을 뜻한다.
    - 객체와 인스턴스
        : 클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화라고 하며, 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 한다.
          인스턴스와 객체는 같은 의미이지만, 객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖고 있으며,
          인스턴스는 어떤 클래스로부터 만들어진 것인지를 강조하는 보다 구체적인 의미를 갖고있다.
            ex) 1) '책상은 객체이다.'      2) '책상은 책상 클래스의 인스턴스이다.'
        : 인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스 타입과 일치해야한다.
    - 객체 배열
        : 모든 배열이 그렇듯이 객체 배열도 원칙적으로는 같은은 타입의 객체만 저장할 수 있다.
          '다형성'을 이용하면 여러 종류의 객체를 하나의 배열에 저장할 수 있다.
    - 클래스
        : 1) 객체를 생성하기 위한 틀이며 속성과 기능으로 정의됨.
          2) 변수: 하나의 데이터를 저장할 수 있는 공간
             배열: 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
             구조체: 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간
             클래스: 데이터와 함수의 결합(구조체+함수)
                : 함수는 주로 데이터를 가지고 작업을 하기 때문에 많은 경우에 있어서 데이터와 함수는 관계가 깊다.
                  그래서 객체지향언어에서는 변수(데이터)와 함수를 하나의 클래스에 정의하여 서로 관계가 깊은 변수와 함수들을 함께 다룰 수 있게 했다.
          3) 사용자정의 타입
    - 변수의 종류
        : 1) 인스턴스 변수
            : 클래스의 인스턴스를 생성할 때 만들어진다. -> 인스턴스 변수의 값을 읽어 오거나 저장하기 위해서는 먼저 인스턴스를 생성해야한다.
              인스턴스는 독립적인 저장공간을 가지므로 서로 다른 값을 가질 수 있다. -> 인스턴스마다 고유한 상태를 유지해야하는 속성의 경우, 인스턴스변수로 선언한다.
          2) 클래스 변수
            : 클래스가 메모리에 올라갈(로딩) 때 만들어지고, 프로그램이 종료될 때 까지 유진된다. -> 인스턴스를 생성하지 않고도 언제라도 바로 사용할 수 있다.
              (*참조변수의 선언이나 객체의 생성과 같이 클래스의 정보가 필요할 때, 클래스는 메모리에 로딩된다.)
              모든 인스턴스가 공통된 저장공간(변수)을 공유하게 된다. -> 한 클래스의 모든 인스턴스들이 공통적인 값을 유지해야하는 속성의 경우, 클래스변수로 선언한다.
          3) 지역변수
        : ==> 인스턴스변수는 인스턴스가 생성될 때 마다 생성되므로 인스턴스마다 각기 다른 값을 유지할 수 있지만, 클래스 변수는 모든 인스턴스가 하나의 저장공간을
              공유하므로, 항상 공통된 값을 가진다.
    - 메서드의 종류
        : 1) 인스턴스 메서드
            : 인스턴스 변수와 관련된 작업을 하는, 즉 메서드의 작업을 수행하는데 인스턴스 변수를 필요로 하는 메서드이다.
              그런데 인스턴스 변수는 인스턴스(객체)를 생성해야만 만들어지므로 인스턴스 메서드 역시 인스턴스를 생성해야만 호출할 수 있는 것이다.
          2) 클래스 메서드
            : 인스턴스와 관계없는(인스턴스 변수나 인스턴스 메서드를 사용하지 않는)메서드이다.
              (인스턴스변수는 인스턴스가 반드시 존재해야만 사용할 수 있는데, 클래스메서드는 인스턴스 생성없이 호출 가능하므로 클래스 메서드가 호출되었을 때,
               인스턴스가 존재하지 않을 수도 있기 때문에 클래스 메서드에서느 인스턴스 변수의 사용을 금지한다.)
              메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다. 메서드 호출시간이 짧아지므로 성능이 향상되기 때문이다.
              (static을 안 붙인 메서드(인스턴스메서드)는 실행 시 호출되어야할 메서드를 찾는 과정이 추가적으로 필요하기 때문에 시간이 더 걸린다.)
    - 변수와 메서드 정리
        ==> 클래스의 멤버변수 중 모든 인스턴스에 공통된 값을 유지해야하는 것이 있는지 살펴보고, 있으면 static을 붙여준다.
        ==> 작성한 메서드 중에서 인스턴스 변수나 인스턴스 메서드를 사용하지 않는 메서드에 static을 붙일 것을 고려한다.

    - JVM의 메모리 구조
        : 응용프로그램이 실행되면, JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고 JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.
          1) 메서드 영역: 프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일(*.class)을 읽어서 분석하여 클래스에 대한 정보(클래스 데이터)를
                        이곳에 저장한다. 이 때, 그 클래스의 클래스변수(static)도 이 영역에 함께 생성된다.
          2) 힙(heap): 인스턴스가 생성되는 공간. 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성된다. 즉, 인스턴스변수들이 생성되는 공간이다.
          3) 호출스택: 메서드의 작업에 필요한 메모리 공간을 제공한다. 메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당되며, 이 메모리는 작업을
                      수행하는 동안 지역변수(매개변수 포함)들과 연산의 중간결과 등을 저장하는데 사용된다. 그리고 메서드가 작업을 마치면 할당되었던 메모리 공간은
                      반환되어 비워진다. (각 메서드를 위한 메모리상의 작업공간은 서로 구별된다.)
    - 매개변수, 반환타입(기본형vs참조형)
        : 메서드를 호출할 때 매개변수로 지정한 값을 메서드의 매개변수에 복사해서 넘겨준다.
          매개변수의 타입이 기본형일 때는 기본형 값이 복사되지만, 참조형이면 인스턴스의 주소가 복사된다.
        : 반환타입이 "참조형"이라는 것은 메서드가 "객체의 주소"를 반환한다는 것을 의미한다.
*/

/*
    - 재귀호출
        : 메서드 입장에서는 자기 자신을 호출하는 것과 다른 메서드를 호출하는 것은 차이가 없다.
          '메서드 호출'이라는 것이 그저 특정 위치에 저장되어 있는 명령들을 수행하는 것일 뿐이기 때문이다.
          호출된 메서드는 값에 의한 호출을 통해, 원래의 값이 아닌 복사된 값으로 작업하기 때문에 호출한 메서드와 관계없이 독릭적인 작업수행이 가능하다.
*/
/*
    - 오버로딩 조건
        : 1) 메서드 이름이 같아야 한다.    2) 매개변수의 개수 또는 타입이 달라야 한다.
    - 가변인자(varargs)와 오버로딩
        : 가변인자는 '타입... 변수명'과 같은 형식으로 선언하며, PrintStream클래스의 printf()가 대표적인 예이다.
                public PrintStream printf(String format, Ojbect... args) { ... }
                String concatenate(String... str) { ... }
                System.out.println(concatenate());          // OK. 인자가 없어도 됨.
                System.out.println(concatenate("a"));
                System.out.println(concatenate("a", "b"));
                System.out.println(concatenate(new String[]{"A", "B"}));    // 배열도 가능
        : 가변인자는 항상 마지막 매개변수이어야 한다.
        : 가변인자는 내부적으로 배열을 이용하는 것이다. 그래서 가변인자가 선언된 메서드를 호출할 때마다 배열이 새로 생성된다.
          가변인자가 편리하지만, 이런 비효율이 숨어있으므로 꼭 필요한 경우에만 가변인자를 사용한다.
        : 가변인자를 매개변수의 타입으로 하는 것과 매개변수의 타입을 배열로 하는 것과의 차이
                String concatenate(String[] str) { ... }
                String result = concatenate(new String[0]); // 인자로 배열을 저장 (*C언어와 달리 자바에서는 길이가 0인 배열을 생성하는 것이 허용됨.)
                String result = concatenate(null);          // 인자로 null을 지정
                String result = concatenate();              // ERROR. 인자가 필요함.
          매개변수의 타입을 배열로 하면, 반드시 인자를 지정해 줘야하기 때문에, 위의 코드에서 처럼 인자를 생략할 수 없다. 그래서 null이나 길이가 0인 배열을
          인자로 지정해줘야 하는 불편함이 있다.
        : 가변인자를 선언한 메서드를 오버로딩하면, 메서드를 호출했을 때 오버로딩한 메서드끼리 구별되지 못하는 경우가 발생하기 쉽기 때문에 주의해야한다.
*/
/*
    - 생성자
        : 연산자 new가 인스턴스가 생성할 때 호출되는 '인스턴스 초기화 메서드'
          단순히 인스턴스변수들의 초기화에 사용되는 조금 특별한 메서드일 뿐이다.
        : Card c = new Card();
            1) 연산자 new에 의해서 메모리(heap)에 Card클래스의 인스턴스가 생성된다.
            2) 생성자 Card()가 호출되어 수행된다.
            3) 연산자 new의 결과로, 생성된 Card인스턴스의 주소가 반환되어 참조변수 c에 저장된다.
            * 인스턴스를 생성할 때는 반드시 클래스 내에 정의된 생성자 중의 하나를 선택하여 지정해 주어야한다.
    - 기본 생성자
        : 기본 생성자가 컴파일러에 의해서 추가되는 경우는 클래스에 저으이된 생성자가 하나도 없을 때 뿐이다.
    - this()
        : 생성자에서 다른 생성자 호출하기 (생성자의 이름으로 클래스이름 대신 this를 사용한다.)
        : 한 생성자에서 다른 생성자를 호출할 때는 바드시 첫 줄에서만 호출이 가능하다.
          생성자에서 다른 생성자를 첫 줄에서만 호출이 가능하도록 한 이유는 생성자 내에서 초기화 작업도중에 다른 생성자를 호출하게 되면,
          호출된 다른 생성자 내에서도 멤버변수들의 값을 초기화를 할 것이므로 다른 생성자를 호출하기 이전의 작업이 무의미해질 수 있기 때문이다.
                Car(String color) {
                    door = 5;
                    Car(color, "auto", r);  // Error1) 생성자의 두 번째 줄에서 다른 생성자 호출
                                               Error2) this(color, "auto", 4); 로 해야함.
                }
    - this
        : 인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되어 있다.
        : 생성자를 포함한 모든 인스턴스메서드에는 자신이 관련된 인스턴스를 가리키는 참조변수 "this"가 지역변수로 숨겨진 채로 존재한다.
          일반적으로 인스턴스메서드는 특정 인스턴스와 관련된 작업을 하기 때문에 자신과 관련된 인스턴스의 정보가 필요하지만,
          static메서드는 인스턴스와 관련 없는 작업을 하기 때문에 인스턴스에 대한 정보가 필요 없다.
          그래서 "this"를 사용할 수 있는 것은 인스턴스멤버 뿐이다. static메서드는 "this" 를 사용할 수 없다.

    - 인스턴스를 생성할 때 결졍해야 할 2가지 사항.
        1) 클래스 - 어떤 클래스의 인스턴스를 생성할 것인가?
        2) 생성자 - 선택한 클래스의 어떤 생성자로 인스턴스를 생성할 것인가?

    - 변수의 초기화
        : 멤버변수(클래스변수, 인스턴스변수)와 배열의 초기화는 선택적이지만, 지역변수의 초기화는 필수적이다.
        : 각 타입의 기본값
            boolean          -> false
            char             -> '\u0000'
            byte, short, int -> 0
            long             -> 0L
            double           -> 0.0d 또는 0.0
            참조형 변수        -> null
    - 멤버 변수의 초기화 방법
        1) 명시적 초기화
            : 변수를 선언과 동시에 초기화하는 것 (가장 우선적으로 고려되어야 한다.), 복잡한 초기화 작업이 필요할 때는 2), 3) 방법으로 초기화 한다.
        2) 생성자
        3) 초기화 블럭
            : 클래스 초기화 블럭 - 클래스변수의 복잡한 초기화에 사용된다.
            : 인스턴스 초기화 블럭 - 인스턴스변수의 복잡한 초기화에 사용된다.
            : 블럭 내에는 메서드 내에서와 같이 조건문, 반복문, 예외처리구문 등을 자유롭게 사용할 수 있으므로, 초기화 작업이 복잡하여 명시적 초기화만으로는
              부족한 경우 초기화 블럭을 사용한다.
              클래스 초기화 블럭은 클래스가 메모리에 처음 로딩될 때 한 번만 수행되며, 인스턴스 초기화 블럭은 생성자와 같이 인스턴스를 생성할 때 마다 수행된다.
              생성자 보다 인스턴스 초기화 블럭이 먼저 수행된다.
              (*클래스가 처음 로딩될 때 클래스변수들이 자동적으로 메모리에 만들어지고, 곧바로 클래스 초기화블럭이 클래스변수들을 초기화하게 되는것이다.)
              인스턴스 변수의 초기화는 주로 생성자를 사용하고, 인스턴스 초기화 블럭은 모든 생성자에서 공통으로 수행돼야 하는 코드를 넣는데 사용한다.
                    // 인스턴스 초기화 블럭
                    {
                        count++;
                        serialNo = count;
                    }
                    Car() {
                        count++;
                        serialNo = count;
                        color = "White";
                        gearType = "Auto";
                    }

                    // 클래스 초기화 블럭
                    static {
                        .....
                    }
    - 멤버변수 초기화 순서
        1) 클래스 변수 초기화
            기본값 -> 명시적 초기화 -> 클래스 초기화 블럭
        2) 인스턴스 변수 초기화
            기본값 -> 명시적 초기화 -> 인스턴스 초기화 블럭 -> 생성자
        ** 클래스 변수는 항상 인스턴스 변수 보다 항상 먼저 생성되고 초기화 된다.
*/
class Funcs {
    // 재귀호출로 n! 구하기 (p.271)
    void rec_func1() {

    }
    // 재귀호출로 1! 부터 n! 까지 각각 구하기
    void rec_func2() {

    }
    // 재귀호출로 x부터 x의 n제곱까지의 합 구하기
    void rec_func3() {

    }

    String concatenate(String delim, String... args) {
        String result = "";
        for(String str : args) {
            result += str + delim;
        }
        return result;
    }
    // 가변인자
    void func4() {
        String[] strArr = { "100", "200", "300" };
        System.out.println(concatenate("", "100", "200", "300"));
        System.out.println(concatenate("-", strArr));
        System.out.println(concatenate(",", new String[]{"1", "2", "3"}));
        System.out.println("[" + concatenate(",", new String[0]) + "]");
        System.out.println("[" + concatenate(",") + "]");
    }
}

public class Main {
    public static void main(String[] args) {

        Funcs f = new Funcs();
        f.func4();
    }
}
















